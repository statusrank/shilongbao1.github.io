<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Statusrank&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/0fa26431bd579c15d2165608b8614017</icon>
  <subtitle>佛系搬砖工</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://statusrank.xyz/"/>
  <updated>2018-09-01T06:49:01.205Z</updated>
  <id>https://statusrank.xyz/</id>
  
  <author>
    <name>Statusrank</name>
    <email>bao_sl@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Wannafly挑战赛23 游戏(sg函数)</title>
    <link href="https://statusrank.xyz/2018/09/01/2018-9-1/"/>
    <id>https://statusrank.xyz/2018/09/01/2018-9-1/</id>
    <published>2018-09-01T06:41:04.000Z</published>
    <updated>2018-09-01T06:49:01.205Z</updated>
    
    <content type="html"><![CDATA[<p></p><h3>题意</h3><br>链接：<a href="https://www.nowcoder.com/acm/contest/161/B" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/161/B</a><br>来源：牛客网<p></p><p>小N和小O在玩游戏。他们面前放了n堆石子，第i堆石子一开始有ci颗石头。他们轮流从某堆石子中取石子，不能不取。最后无法操作的人就输了这个游戏。但他们觉得这样玩太无聊了，更新了一下规则。具体是这样的：对于一堆有恰好m颗石子的石头堆，假如一个人要从这堆石子中取石子，设他要取石子数为d，那么d必须是m的约数。最后还是无法操作者输。<br>现在小N先手。他想知道他第一步有多少种不同的必胜策略。一个策略指的是，从哪堆石子中，取走多少颗石子。只要取的那一堆不同，或取的数目不同，都算不同的策略。<br><a id="more"></a><br>输入描述:<br>第一行一个整数n。<br>接下来一行n个整数，分别代表每堆石子的石子数目。<br>数据保证输入的所有数字都不超过105，均大于等于1，且为整数。<br>输出描述:<br>一行一个整数代表小$N$第一步必胜策略的数量。<br>示例1<br>输入<br>复制<br>10<br>47 18 9 36 10 1 13 19 29 1<br>输出<br>复制<br>7</p><p></p><h3>思路:</h3><br>典型的sg函数问题,n堆可以看成先求每堆的sg然后异或,这里不同的就是因为只能取因子,所以sg的时候按照因子个数来取。对于有多少种取法,只需要对于每一堆我们看一下取因子个数后,是否还满足sg函数必胜态的条件:sg1^sg2^sg3… == 0.也就是把必败态扔给对手,然后统计即可<p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> a[maxn],vis[<span class="number">1000</span>],sg[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsg</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sg[x] != <span class="number">-1</span>) <span class="keyword">return</span> sg[x];</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j * j &lt;= x;++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x % j) <span class="keyword">continue</span>;</span><br><span class="line">        vis[getsg(x - j)] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x / j != j) vis[getsg(x - x / j)] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= x;++i)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) <span class="keyword">return</span> sg[x] = i;</span><br><span class="line">    <span class="keyword">return</span> sg[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(sg,<span class="number">-1</span>,<span class="keyword">sizeof</span> sg);</span><br><span class="line">    sg[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;++i) sg[i] = getsg(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        res ^= sg[a[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        res ^= sg[a[i]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j*j &lt;= a[i];++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]%j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>( !(res ^ sg[a[i] - j])) cnt++; <span class="comment">//这里需要注意的是:比较运算符优先级大于逻辑运算符。</span></span><br><span class="line">            <span class="keyword">if</span>(a[i] / j != j &amp;&amp; !(res ^ sg[a[i] - a[i] / j]))</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        res ^= sg[a[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;h3&gt;题意&lt;/h3&gt;&lt;br&gt;链接：&lt;a href=&quot;https://www.nowcoder.com/acm/contest/161/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.nowcoder.com/acm/contest/161/B&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;p&gt;&lt;/p&gt;
&lt;p&gt;小N和小O在玩游戏。他们面前放了n堆石子，第i堆石子一开始有ci颗石头。他们轮流从某堆石子中取石子，不能不取。最后无法操作的人就输了这个游戏。但他们觉得这样玩太无聊了，更新了一下规则。具体是这样的：对于一堆有恰好m颗石子的石头堆，假如一个人要从这堆石子中取石子，设他要取石子数为d，那么d必须是m的约数。最后还是无法操作者输。&lt;br&gt;现在小N先手。他想知道他第一步有多少种不同的必胜策略。一个策略指的是，从哪堆石子中，取走多少颗石子。只要取的那一堆不同，或取的数目不同，都算不同的策略。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ACM" scheme="https://statusrank.xyz/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识点总结</title>
    <link href="https://statusrank.xyz/2018/08/30/1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://statusrank.xyz/2018/08/30/1操作系统/</id>
    <published>2018-08-30T10:56:01.000Z</published>
    <updated>2018-09-01T09:52:01.273Z</updated>
    
    <content type="html"><![CDATA[<h3>可重定位分区分配</h3><p>  在连续分配方式中，必须把一个系统或用户程序装入一连续的内存空间。如果在系统中只有若干个小的分区，即使它们的容量总和大于要装入的程序，但由于这些分区不相邻接，也无法把该程序装入内存。这种不能被利用的小分区称为“零头”或“碎片”。<br><a id="more"></a><br>当内存中出现几个互不相邻的小分区,他们单独的容量不能满足要求,但他们的总容量和大于作业的要求,<font color="red">这时就可以将内存中的所有作业进行移动,使他们全部相邻接,这样就把原来的小分区拼接成大分区来满足要求。</font><br>  第一种方案是在某个分区回收时立即进行拼接，这样在内存中总是只有一个连续的空闲区。但由于拼接很费时间，拼接频率过高会使系统开销加大。<br>  第二种方案是当找不到足够大的空闲区且空闲区的总容量可以满足作业要求时进行拼接。拼接的频率比第一种要小得多，但空闲区的管理稍微复杂一些。 （需要重定位寄存器）</p><p></p><h3>进程和线程的区别</h3><br>进程是运行时的程序,是系统进行资源调度和分配的基本单位,实现了操作系统的并发。<br>线程是CPU调度和分配的基本单位,一个进程至少有一个线程,线程是依赖于进程存在的。<br>进程在执行过程中拥有独立的内存单元,而多个线程共享进程的内存。<p></p><p></p><h3>进程间通信的方式</h3><br>进程通信,即进程间进行数据交换。<p></p><p></p><h4>管道</h4><br>管道是一种供内存共享的外存文件,主要是用于连接一个写入进程和一个读出进程以实现他们之间的数据通信。<br>管道分为无名管道和有名管道。<br>1.互斥问题。管道文件应看成临界资源,对管道文件的访问应该互斥的进行。当一个进程对管道读/写时,另一个进程不可以访问他。<br>2.同步<br>先写后读,读完才能继续写.<p></p><p></p><h4>消息队列</h4><br>消息队列是消息的链接表,具有写权限的进程可以按照一定的规则向消息队列中添加信息；对消息队列有读权限的进程可以从消息队列中读取信息。<p></p><p></p><h4>共享内存</h4><br>多个进程可以访问同一块内存空间,不同进程可以及时看到对方进程中对共享内存数据的更新。这种方式需要依靠某种同步操作,如互斥锁和信号量等。<p></p><p></p><h4>信号量</h4><br>进程之间及同一种进程的不同线程之间取得同步和互斥的手段<p></p><p></p><h4>套接字</h4><br>可以用于网络中不同机器之间的进程间通信<p></p><p></p><h3>线程同步的方式</h3><br>互斥量:采用互斥对象机制,只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个,所以可以保证公共资源不会被多个线程同时访问。<br>信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量<br>事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作<p></p><p></p><h3>什么是死锁？死锁产生的条件？</h3><br>1)死锁的概念<br>在两个或多个并发进程中,存在这样一组进程;每个进程都持有某种资源而又等待其他进程所占有的资源,在未改变状态前这些进程都不能前进,陷入了无休止的等待。<br>2）产生死锁的原因、产生死锁的条件<br>互斥条件。进程请求的资源属于临界资源,每次只能允许一个进程使用<br>不剥夺条件。进程获得某个资源后就一直占有，直到使用完后才释放<br>请求和等待条件。允许进程在保持已有资源不释放的情况下进一步请求新的资源,若请求的资源得不到满足将会阻塞,也不释放自己所持有的资源<br>环路条件。若干进程之间形成了一种头尾相连的环形等待资源关系.<p></p><p></p><h3>死锁的处理基本策略和常用方法</h3><br>解决死锁的方法有死锁预防、死锁避免、检测死锁、解除死锁等。<p></p><p></p><h4>死锁预防</h4><br>基本思想<font color="red">只要确保死锁发生的四个必要条件至少有一个不成立即可</font><br>1)<strong><em>打破“请求和保持条件”</em></strong><br>一次性分配方案:在进程创建开始时将整个运行期间所需的全部资源一次性分配到手,其运行过程中不许再追加申请。<br>这种方法简单易行,但是会造成资源浪费,大部分时间里全部分配的资源是闲置不用的,这就造成了浪费。其次,很多情况下我们无法预知一个进程执行前所需的全部资源,因为进程是动态执行的,不可预知的；同时降低了程序的并发性。<br>2)<strong><em>打破不可剥夺条件</em></strong><br>一个进程不必一次性地申请全部所需资源,允许采用动态申请的方式;但是当申请的资源得不到满足时就释放自己所占有的全部资源使得其他进程使用。<br>实现起来复杂,使系统开销增加。<br>3）<strong><em>打破环路条件</em></strong><br>实行资源的有序分配。对所有资源编号,所有进程对资源的请求必须严格按照资源序号递增提出,即占有了小号资源才能申请大号资源,这样就不产生回路，预防死锁的发生。<p></p><p></p><h4>死锁避免</h4><br>基本思想:动态监测资源分配状态,以确保循环等待条件不成立,从而确保系统处于安全状态。<br>安全状态:系统是否存在一个进程序列,使得系统按此序列执行时,所有进程都能到达终点。<br><strong><em>银行家算法</em></strong><br>在运行中实现动态测试,决定是否满足用户当前的需求，系统开销大。<p></p><p></p><h4>死锁检测</h4><br>死锁定理:系统状态S为死锁状态的充要条件是,S状态的资源分配图是不可化简的。<p></p><p></p><h4>死锁消除</h4><br>死锁消除的方法有:撤销进程法和资源剥夺法.<br>1）撤销进程法<br>撤销部分死锁的进程,用释放出来的资源救活其他死锁的进程。每撤销一个进程就采用死锁检测的方法检测死锁是否解除,若不解除继续撤销进程直到死锁解除为止。<br>2）资源剥夺法<br>将一个阻塞进程挂起后,剥夺该进程所有占有的资源,并保存他在挂起点前的状态,在以后该进程被激活时从以前的状态处继续执行.<p></p><p></p><h3>进程有哪些状态？</h3><br>就绪态、运行态、阻塞态、挂起态、退出态<p></p><p></p><h3>分页和分段有什么区别(内存管理)?</h3><p></p><p></p><h4>分页</h4><br>将内存空间划分为一些大小相同的存储块————“帧”<br>进程划分为与帧同样大小的块称为—————“页面”，每一页面放入一帧中，&lt;页号，页内地址&gt;<br>页表:为每一个进程建立的表,对应记录着每一页放在哪一帧中。<p></p><p></p><h4>分段</h4><br>一个进程可以由很多段组成,各个段长度并不一定相同,所以为每个段分配等长的存储空间是不现实的,所以采用动态分区分配的机制,根据各个段的长度给予分配大小不等的一些存储块,并允许进程被放在不连续的空间中<p></p><p></p><h4>两者的不同点</h4><br>1.分页不存在外碎片,但是会产生内碎片。分段会产生外碎片,没有内碎片<br>2.大小:页的大小固定且由系统决定,而段的长度不固定,由其所完成的功能决定<br>3.地址不同:段向用户提供二维地址空间,页向用户提供一维地址空间<p></p><p></p><h3>操作系统中进程调度策略</h3><br>FCFS(先来先服务，队列实现，非抢占的)：先请求CPU的进程先分配到CPU<br>SJF(最短作业优先调度算法)：平均等待时间最短，但难以知道下一个CPU区间长度<br>优先级调度算法(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：老化<br>时间片轮转调度算法(可抢占的)：队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。<br>多级队列调度算法：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。<br>多级反馈队列调度算法：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。<p></p><p></p><h3>什么是虚拟内存?</h3><br><strong><em>虚拟内存的基本思想:</em></strong>每个进程拥有独立的地址空间,这个空间被分为大小相等的多个块,称为页(page),每个页都是一段连续的地址,这些页被映射到物理内存,但并不是所有的页必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时,由硬件立刻进行必要的映射;当程序引用到一部分不再物理内存中的地址空间时,由操作系统负责将缺失的部分装入物理内存。<font color="red">对于进程而言,逻辑上有很大的内存空间,实际上其中一部分对应物理内存上的帧,还有一些并没有加载到内存上而是保存在磁盘中</font><br><img src="/2018/08/30/1操作系统/1.jpg"><br>由上图可以看出虚拟内存实际上比物理内存大。当访问虚拟内存时,会访问内存管理单元(MMU)，去匹配对应的物理地址。<strong><em>如果虚拟内存的页并不存在于物理内存中,会产生缺页中断,从磁盘中读出放入内存,若内存满还会使用相应的页面置换算法.</em></strong><p></p><p></p><h4>页面置换算法</h4><br>1.先进先出FIFO。<br>2.最近最久未使用LRU,根据使用时间到现在的长短来判断<br>3.最少使用次数LFU,根据使用次数来判断<br>4.最优置换算法OPT，就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。<br>5.clock算法<br>设置一个访问位 A,A = 0 表明该页最近未访问,A = 1表明该页最近访问过。<br>当需要置换页时: 旋转一周,找到一个A = 0 的将其置换出去,若A = 1该页不置换,但需要将A置成0,直到找到一个A=0的为止。<br>6.改进的clock算法<br>我们可以观察到,如果置换一个修改过的页比置换一个未修改的页麻烦。因为被修改的页需要重新写回外存。所以这里我们增加一个修改位M。<br>A=0,M=0该页最近未被访问,未修改<br>A=0，M=1该页最近未被访问，但被修改了<br>A=1，M=1该页最近被访问了但是没修改<br>A=1,M=1该页最近被访问了也被修改了。<br>当需要置换页时:<br>第一圈:找到一个A=0,M=0的并将其置换出去。<br>若没有这样的页,则找到一个A=0，M=1的将其置换出去；在这个过程中需要将A=1的置为A=0.循环以上直到找到满足条件的页为止<p></p><p></p><h4>局部性原理</h4><br>时间:最近被访问的页在不久的将来还会被访问<br>空间:内存中被访问的页周围的页也很可能被访问<p></p><p></p><h3>缓冲管理</h3><br>外部设备和CPU之间存在速度上的差异,为了缓解差异引入缓冲技术。<p></p><p></p><h4>引入缓冲技术的优点</h4><br>1.减少磁盘的驱动次数<br>2.可以缓解I/O对缺页置换策略的干扰<br>3.缓解CPU与外设速度不匹配的矛盾,使数据处理速度提高<p></p><p></p><h4>缓冲池技术</h4><br>缓冲池:一种可以被多用户,多任务共享的缓冲区,是系统提供的一种共享结构,不归进程所有。<br>1.缓冲池由三个队列组成:<br>空闲缓冲队列emq。挂有全部克用的空闲缓冲块。<br>输入队列inq。挂有装满输入数据的缓冲块。<br>输出队列outq。挂有装满输出数据的缓冲块。<p></p><p></p><h4>缓冲区四种工作方式</h4><br><img src="/2018/08/30/1操作系统/2.jpg"><br>收容输入,提取输入,收容输出,提取输出<p></p>]]></content>
    
    <summary type="html">
    
      &lt;h3&gt;可重定位分区分配&lt;/h3&gt;

&lt;p&gt;  在连续分配方式中，必须把一个系统或用户程序装入一连续的内存空间。如果在系统中只有若干个小的分区，即使它们的容量总和大于要装入的程序，但由于这些分区不相邻接，也无法把该程序装入内存。这种不能被利用的小分区称为“零头”或“碎片”。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="各种基础知识" scheme="https://statusrank.xyz/tags/%E5%90%84%E7%A7%8D%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>C++知识点总结</title>
    <link href="https://statusrank.xyz/2018/08/29/1C/"/>
    <id>https://statusrank.xyz/2018/08/29/1C/</id>
    <published>2018-08-29T09:30:59.000Z</published>
    <updated>2018-08-29T11:57:07.655Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>1.c和c++的区别是什么？</em></strong><br>    程序 = 数据结构+算法.c语言是面向过程的,面向过程就是分析出解决问题的步骤,然后用函数将其实现,使用时依次调用.</p><pre><code>程序= 对象+消息.c++是面向对象的,c++面向对象是将构成问题的事物分解成各个对象，每个对象完成在解决整个问题中的行为.主要特点是类，封装，继承，多态等。面向对象的语言具有更好的可扩展性。</code></pre><a id="more"></a><p><strong><em> 2.const有什么用途?</em></strong><br>    （1）定义一个常量,即该数据只读,发生更改会报错</p><pre><code>（2）修饰函数返回值和函数的参数,增加程序的健壮性（3）修饰函数定义体.(也就是说这个函数为一个只读函数,该函数不会修改任何数据成员的值) 例如: void getDescription() const; 被const修饰过的函数能被const和非const对象调用,但是const对象只能调用被const修饰过的函数定义体.</code></pre><p><strong><em>3.指针和引用的区别是是什么？</em></strong><br>    （1）引用是变量的一个别名,引用与他所引用的变量实际上代表同一个存储单元</p><pre><code>  (2) 引用相比指针对内存的占用少,节省内存空间。（3）引用是一个绑定的关系,绑定关系是永久的,而指针可以改变（4）常引用的值不能被修改,主要用途是函数的形参以及函数的返回引用</code></pre><p><strong><em>4.malloc/free 和 new/delete的区别是什么？或者说为什么有了malloc/free 还需要new/delete？</em></strong><br>        (1)new 自动计算要分配的存储区的大小,而malloc需要给出所需要分配的存储区的大小.且new会自动返回正确的指针类型。</p><pre><code>  （2）new 可以对分配的存储空间进行初始化，也可以创建对象并对对象进行初始化（创建是调用构造函数,释放时调用析构函数）.  （3）new/delete可以重载,重载一个与类相关的new/delete运算符.</code></pre><p><strong><em>5.数据封装、继承、多态</em></strong></p><pre><code>数据封装：实现了信息隐蔽性,将数据和数据有关的操作集合封装到一起,用户不必知道其实现细节,只需要知道功能即可。 继承: 解决了软件的可重用性和可扩展性 多态性:一个名字或符号具有多种含义,通过重载来实现的. 例如:c++中存在同名函数,根据参数不同自动匹配.</code></pre><p><strong><em>6.静态成员与静态成员函数</em></strong><br>静态成员属于类,而不属于对象。无论创建多少个该类的对象,都只有一个静态数据的存储空间,静态数据的初始化不会自动进行,必须在类外初始化.。<br>        类型名 类名:: 静态数据成员[= 常量表达式]<br>  静态成员函数也属于类而不是某个对象。在类外调用一个公有静态成员函数不需要指明对象或指向对象的指针。方式为: 类名:: 静态公有成员函数名(参数列表)<br><strong><em>7.构造函数、析构函数、拷贝构造函数、友元函数</em></strong><br>    一个类只能由一个析构函数。但却可以有多个构造函数,即可以重载构造函数。<font color="red">析构函数的调用顺序和构造函数的调用顺序相反</font><br>    拷贝构造函数用于创建一个新对象并从已存在的对象中依据规则复制数据。缺省的拷贝构造函数采用内存拷贝的形式，将已经存在对象的内存一个字节一个字节的拷贝到新建对象的内存当中。<br>    友元函数没有this指针,一个类的友元可以访问该类的所有成员,包括私有和受保护的,这是基于效率的考虑</p><p><strong><em>8.继承和派生</em></strong><br>  <strong><strong>派生</strong></strong>:首先是继承基类的成员,再修改和增加派生类具有的自己特性的成员。通过派生,派生类在基类的基础上可以获得可重用性和可扩充性,既具备基类的特征又添加了自己的功能。构造函数和析构函数是不能被继承的。<br>  <strong><em>多重继承</em></strong>:一个派生类有两个或两个以上的基类。<br><strong><em>继承的意义:</em></strong>从模块的观点,继承是一种关键的可重用和可扩充技术；从类型的观点,继承的关键是动态匹配。<br><strong><em>公有派生</em></strong>:<br>(1)基类的保护成员在派生类中仍然是保护成员<br>(2)基类的公有成员在派生类中仍然是公有成员<br>(3)基类的私有成员在派生类中成为不可访问成员<br><strong><em>私有派生</em></strong>:<br>(1)基类的保护成员在派生类中仍然是私有成员<br>(2)基类的公有成员在派生类中仍然是私有成员<br>(3)基类的私有成员和不可访问成员在派生类中成为不可访问成员<br><strong><em>保护派生</em></strong><br>基类所有公有段和保护段成员在保护派生中成为保护段。</p><font color="red">保护段的作用:保护派生使得基类的一些成员,他们可以被派生类访问,但不能被其他类访问(类内访问)。也就是说除了基类和他的派生类可以看到这部分成员外,对其他类如同私有段成员函数一样。</font><font color="red">***基类和派生类共享基类的static成员,要求访问静态成员比用"类名::成员"显示的访问***</font><p>派生类的对象创建的时候一定会调用构造函数初始化该类对象,且一定会先调用基类的构造函数(首先基类,其次对象成员,最后派生类),执行析构函数的顺序是相反的。<br><strong><em>访问声明</em></strong><br>仅适用于私有派生,且不能说明任何类型。<br>类D从基类B中私有派生,则D的派生类E不能访问基类B中的任何成员,为了满足需要可以采用访问声明,使得B的几个成员可以被E访问。<br>即在类D中重新声明从基类B中继承的几个成员的类型:<br>基类类名:基类保护段或公有段数据成员<br>基类类名:基类保护段或公有段成员函数<br><strong><em>9.抽象类</em></strong></p><pre><code>抽象类指的是含有纯虚函数的类，该类不能建立对象，只能声明指针和引用，用于基础类的接口声明和运行时的多态 另外，如果抽象类的某个派生类在向继承体系的根回溯过程中，并不是所有的纯虚函数都实现了，该类也是抽象类，同样不能建立对象。</code></pre><p></p><h3>虚基类</h3><br>防止有多个间接基类的多个实例。<br><strong><em>虚基类构造函数的调用次序</em></strong><br>虚基类的构造函数在非虚基类之前调用<br>若同一层次中包含多个虚基类,虚基类构造函数按他们的说明顺序调用<br>若虚基类由非虚基类派生,则遵守先调用基类构造函数再调用派生类构造函数的规则<p></p><p></p><h3>11.虚函数</h3><br>虚函数是一种在基类函数中定义为virtual的函数,并在一个或多个派生类中再定义的函数。虚函数的特点是，只要定义一个基类的指针，就可以指向派生类的对象。<br>注：无虚函数时，遵循以下规则：C++规定，定义为基类的指针，也能作指向派生类的指针使用，并可以用这个指向派生类对象的指针访问继承来的基类成员；但不能用它访问派生类的成员。<p></p><font color="red">使用虚函数实现运行时的多态性的关键在于：必须通过基类指针访问这些函数。</font>一旦一个函数定义为虚函数，无论它传下去多少层，一直保持为虚函数.把虚函数的再定义称为过载（overriding）而不叫重载（overloading）。**纯虚函数：**是定义在基类中的一种只给出函数原型，而没有任何与该基类有关的定义的函数。纯虚函数使得任何派生类都必须定义自己的函数版本。否则编译报错。纯虚函数定义的一般形式：Virtual type func_name(参数列表)=0; 虚函数要求参数列表类型返回值完全一样!<font color="red">重载一般函数式,函数的返回类型和参数列表可能是不同的,仅仅要求函数名相同。重载虚函数时,要求函数名、返回类型、参量个数、参数类型和顺序是完全相同的,若仅仅是函数名相同,C++会认为这是一般的函数重载,那么此时虚函数特性就会消失.</font><p>l  含有纯虚函数的基类称为抽象基类。<font color="red">抽象基类又一个重要特性：抽象类不能建立对象。但是抽象基类可以有指向自己的指针，以支持运行时的多态性。</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ECHO(str) std::cout &lt;&lt; str</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ECHOLN(str) std::cout &lt;&lt; str&lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* run this program using the consolepauser or add your own getch, system("pause") or input loop */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">                       <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">                        ECHOLN(<span class="string">"我是基类！"</span>);</span><br><span class="line"></span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deriv_1</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">                   voidwho()&#123;</span><br><span class="line"></span><br><span class="line">                            ECHOLN(<span class="string">"我是子类deriv_1"</span>);</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                  </span><br><span class="line"></span><br><span class="line">         &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deriv_2</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">                  <span class="function"><span class="keyword">void</span> <span class="title">who</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">                            ECHOLN(<span class="string">"我是子类deriv_2"</span>);</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">         classBase *b,b0;</span><br><span class="line"></span><br><span class="line">         classderiv_1 d1;</span><br><span class="line"></span><br><span class="line">         classderiv_2 d2;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">         b= &amp;b0;</span><br><span class="line"></span><br><span class="line">         b-&gt;who();</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">         b= &amp;d1;</span><br><span class="line"></span><br><span class="line">         b-&gt;who();</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">         b= &amp;d2;</span><br><span class="line"></span><br><span class="line">         b-&gt;who();</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">         return0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p>我是基类！</p><p>我是子类deriv_1</p><p>我是子类deriv_2</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;1.c和c++的区别是什么？&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;    程序 = 数据结构+算法.c语言是面向过程的,面向过程就是分析出解决问题的步骤,然后用函数将其实现,使用时依次调用.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;程序= 对象+消息.c++是面向对象的,c++面向对象是将构成问题的事物分解成各个对象，每个对象完成在解决整个问题中的行为.主要特点是类，封装，继承，多态等。面向对象的语言具有更好的可扩展性。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="各种基础知识" scheme="https://statusrank.xyz/tags/%E5%90%84%E7%A7%8D%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>牛客练习赛25 定向(桥+tarjan)</title>
    <link href="https://statusrank.xyz/2018/08/26/%E5%AE%9A%E5%90%91/"/>
    <id>https://statusrank.xyz/2018/08/26/定向/</id>
    <published>2018-08-26T12:51:44.000Z</published>
    <updated>2018-08-26T13:00:00.005Z</updated>
    
    <content type="html"><![CDATA[<p></p><h3>题意</h3><br>给一张无向图，你需要将边定向，使得定向后的有向图强连通。<br><a id="more"></a><p></p><p></p><h3>思路</h3><br>难点在于如何判断结果不存在。<br>依据连通分量的知识,可以得出结论:如果给定的无向图中存在桥的话,结果一定不存在,否则我们一定可以找出答案,且这个答案直接dfs即可。<br><a href="https://statusrank.xyz/2018/08/26/%E5%BC%BA%E8%81%94%E9%80%9A%E5%88%86%E9%87%8F/">如何判断是否有桥</a><br>这里因为是否有桥的判定为,子节点v low[v] &gt; 父节点dfn[u]。<br>若不存在这样的点说明所有的子节点都存在返祖边指向其祖先,而因为我们是dfs,祖先又有边指向子节点,可想而知此时就是一个连通图.所以在从起始点dfs一下分边即可。(可知,答案不唯一)<p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cnt,cont;</span><br><span class="line"><span class="keyword">int</span> dfn[maxn],low[maxn],head[maxn],fa[maxn],vis[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt,dir,used;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>,cont = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        head[i] = <span class="number">-1</span>,vis[i] = <span class="number">0</span>,fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[cnt].to = b;</span><br><span class="line">    e[cnt].nxt = head[a];</span><br><span class="line">    e[cnt].used = <span class="number">0</span>;</span><br><span class="line">    head[a] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> par)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[cur] = low[cur] = cont++;</span><br><span class="line">    fa[cur] = par;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[cur];~i;i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nxt = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[nxt])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(nxt,cur);</span><br><span class="line">            low[cur] = min(low[cur],low[nxt]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nxt != par)&#123; <span class="comment">//不通过父亲访问祖先</span></span><br><span class="line">            low[cur] = min(low[cur],dfn[nxt]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[cur];~i;i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nxt = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(e[i].used) <span class="keyword">continue</span>;</span><br><span class="line">        e[i].used = <span class="number">1</span>,e[i^<span class="number">1</span>].used = <span class="number">1</span>; <span class="comment">// i 和 i^1 是一对反向边</span></span><br><span class="line">        e[i].dir = <span class="number">1</span>,e[i^<span class="number">1</span>].dir = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(vis[nxt]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[nxt] = <span class="number">1</span>;</span><br><span class="line">        dfs(nxt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b);</span><br><span class="line">        add(a,b),add(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    tarjan(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> par = fa[i];</span><br><span class="line">        <span class="keyword">if</span>(low[i] &gt; dfn[par]) <span class="comment">// 存在桥一定不可能</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cnt;i += <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,e[i].dir);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;h3&gt;题意&lt;/h3&gt;&lt;br&gt;给一张无向图，你需要将边定向，使得定向后的有向图强连通。&lt;br&gt;
    
    </summary>
    
    
      <category term="ACM" scheme="https://statusrank.xyz/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>强连通分量以及tarjan算法</title>
    <link href="https://statusrank.xyz/2018/08/26/%E5%BC%BA%E8%81%94%E9%80%9A%E5%88%86%E9%87%8F/"/>
    <id>https://statusrank.xyz/2018/08/26/强联通分量/</id>
    <published>2018-08-26T12:12:07.000Z</published>
    <updated>2018-08-26T12:51:21.081Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/mengxiang000000/article/details/51672725" target="_blank" rel="noopener">参考这里</a><br><a href="https://www.cnblogs.com/nullzx/archive/2017/12/04/7968110.html" target="_blank" rel="noopener">还有这里</a></p><h1>什么是强连通分量?</h1><p>1.强连通分量是相对于有向图来说的,在有向图G中,若任意两个点都可达,则称图G是强连通图。<br>如果存在两个顶点u和v,u不能到v或者v不能到u,则称图G为强非连通图<br>2.如果G不是一个强连通图,它的子图G2是强连通图,V属于G2,任意包含V的强连通子图也是G2的子图,那么G2就是G的极大强连通子图,也叫做强连通分量。<br><a id="more"></a><br>3.所谓强连通,就是图中有两点u和v,使得能够找到有向路径从u到v以及v到u。</p><h1>什么是割点和桥(割边)？</h1>割点和桥的定义是相对于无向图来说的。割点: 无向连通图中,去掉一个顶点及和它相邻的所有边,图中的连通分量数增加,则该顶点为割点。(也可以理解成使原来的连通部分变得不再连通)桥(割边):无向连通图中,去掉一条边,图中的连通分量数增加,则这条边成为桥或者割边。<h2>割点和桥的关系</h2>有割点不一定有桥,但是有桥一定有割点。也就是说桥一定是与割点相连的边。如图: <img src="/2018/08/26/强联通分量/1.png"><h1>什么是tarjan算法?</h1>tarjan算法,其本质是基于dfs的思想,利用dfs遍历得到生成树的访问顺序从而找出在一个强连通分量中的关键节点,从而找到整个强连通分量。<h3>dfn[] 和low[]</h3>首先我们需要定义两个数组,这两个数组也是tarjan的核心思想。dfn[] ，i表示顶点的编号,dfn[i]的值表示该顶点在dfs中的遍历顺序,每访问到一个未访问过的点该点的时间戳就+1.由此在dfs中我们可以得到:子节点的dfn一定大于父节点的dfn,而且在访问一个结点后其dfn便确定了,不会再改变。low[]，下标表示顶点编号,low的值表示该点所能到达的点的时间戳的最小值。(这个当然是需要回溯维护的)当然因为子节点的dfn一定大于父节点,所以low值主要维护的自己所能访问的祖先的时间戳的最小值。我们也是通过它和dfn的关系来判断是否为关键节点。具体例子请看上面两个博客,都很不错。根据tarjan算法,当我们遍历完所有u所能到达的子节点时,若有low[u] == dfn[u] 那么这个点就是关键节点,同时也是进入强连通分量的起始节点(我们可以知道强连通分量一定有环的)。代码只是用来做一个参考:<h3>如何找到强连通分量中的所有点呢？</h3>我们知道当遍历完u所有能到达的点再回溯到u时,那么与u无关的点已经出栈；栈顶上这些的点一定是通过u dfs入栈的,我们又说过当满足条件是u是强连通分量的入口结点,所以此时栈顶一直到u出栈，之间这些点都是属于一个强连通分量的。<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> dfs(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    dfn[x] = low[x] = ++_lock;</span><br><span class="line">    st.push(x);</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; vt[x].<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = vt[x][i];</span><br><span class="line">        <span class="built_in">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(v);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x],low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">else</span> <span class="built_in">if</span>(!belong[v])</span><br><span class="line">        &#123;</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x],dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">if</span>(low[x] == dfn[x]) <span class="comment">//这一部分是找到强连通分量中的所有点</span></span><br><span class="line">    &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="built_in">while</span>(!st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> w = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            belong[w] = cnt;</span><br><span class="line">            cost[cnt] += a[w];</span><br><span class="line">            <span class="built_in">if</span>(w == x)</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> solve() <span class="comment">//缩点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; vt[i].<span class="built_in">size</span>();++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = vt[i][j];</span><br><span class="line">            <span class="built_in">if</span>(belong[i] != belong[v])</span><br><span class="line">            &#123;</span><br><span class="line">                af[belong[i]].pb(belong[v]);</span><br><span class="line">                in[belong[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mi = <span class="number">1e18</span>;</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">if</span>(in[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mi = <span class="built_in">min</span>(mi,cost[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; mi &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>如何利用tarjan算法来求割点或桥？</h1><p>我们重新复习下上面我们定义的两个数组,dfn[]表示该顶点在dfs遍历中是第几个被访问的,也可以理解成是时间戳。low[]表示该点所能到达的祖先的最小顺序值(上面说过主要是对祖先起作用)。</p><p>那么我们可以得出如下结论:<br>1.割点:<br>判断u是否为割点,只需要拿u的dfn值和其所有子节点的low[v]比较,如果low[v]&gt;= dfn[u] 则u为割点。<br>low[v] &gt;= dfn[u] 这说明v要访问u的祖先顶点必须经过u结点,若不是根据tarjan算法,low值肯定会比dfn[u]小(因为u的祖先一定比u的dfn小)。<br>2.桥:<br>判断是否有桥,我们上面说过桥一定是直接和割点相连的。所以我们得出条件: low[v] &gt; dfn[u]有桥。</p><p>这里没有等号的原因: 若low[v]==dfn[u] 说明从v可以回到u,也就是说即使删了u到v的边,还存在其他路径是u，v仍然连通。</p><p>具体例子请看<a href="https://www.cnblogs.com/nullzx/archive/2017/12/04/7968110.html" target="_blank" rel="noopener">here </a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/mengxiang000000/article/details/51672725&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考这里&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/nullzx/archive/2017/12/04/7968110.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;还有这里&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;什么是强连通分量?&lt;/h1&gt;

&lt;p&gt;1.强连通分量是相对于有向图来说的,在有向图G中,若任意两个点都可达,则称图G是强连通图。&lt;br&gt;如果存在两个顶点u和v,u不能到v或者v不能到u,则称图G为强非连通图&lt;br&gt;2.如果G不是一个强连通图,它的子图G2是强连通图,V属于G2,任意包含V的强连通子图也是G2的子图,那么G2就是G的极大强连通子图,也叫做强连通分量。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ACM" scheme="https://statusrank.xyz/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>deeplearning.ai-note 结构化机器学习项目</title>
    <link href="https://statusrank.xyz/2018/08/24/%E7%BB%93%E6%9E%84%E5%8C%96%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE/"/>
    <id>https://statusrank.xyz/2018/08/24/结构化机器学习项目/</id>
    <published>2018-08-24T13:29:54.000Z</published>
    <updated>2018-08-25T07:31:33.610Z</updated>
    
    <content type="html"><![CDATA[<p></p><h1>前言</h1><br>本文是吴恩达deeplearning.ai 第三部分结构化机器学习项目学习笔记,<strong><em>主要是在做项目时的策略总结</em></strong><font color="red">学习这一部分可以教你少走弯路,在何时应该选择什么样的策略使得自己的项目向着最好的方向发展。</font><br><a id="more"></a><p></p><p></p><h1>项目策略</h1><br>在整个深度学习的训练过程中,为了提高精确度、拟合程度，要不断的调参、更改一些算法或增加数据等等,对此我们有很多的路径可以走,那么我们如何知道应该选择什么路径才是有效的呢？<p></p><h2>正交化</h2>正交化就是将深度学习的整个过程的所有需要解决的问题独立开来。针对某个方面的问题有相应的解决方法,尽量不要用一个方法去尝试解决多个方面的问题。![](https://i.imgur.com/zdfDnKI.jpg)如上图,主要有四个方面的问题:拟合训练集,拟合验证集,拟合测试集,在实际使用中能够很好的泛化。最好的是一个个解决问题,先拟合训练集,然后拟合验证集,测试集,在实际中应用。如果用early stopping之类的同时影响两个问题的方法就不是很好。<h2>指标</h2>dev set和指标很重要，先确定下来后再根据实际情况不断修改，让他们更加符合实际应用时的场景。<h3>单一数字评估指标</h3>查准率decision：就是精确度。例子：猫分类器判断一些图是猫，在这些图中真的是猫的图的比例就是查准率。查全率recall:在所有猫图片中分类器正确判断出了多少在有多个算法和模型时,需要判断哪个更好,就需要一个指标来衡量,建议不要使用多个指标,这样就很难迅速判断。最好的方法是将几个学习模型的指标平均,**得出一个单一的评估标准用于以后的衡量**其中有一个比较好的就是调和平均数。**单一指标的设定并不仅仅是一个简单的量或平均值,可以是复杂的加权结果,取决于实际应用的需要。**<h3>优化指标、满足指标</h3>如果有几个指标不能很好的融合成单一指标,就可以用优化指标,满足指标的方法。假设有k个指标,就指定k-1个位满足指标,意思是只要这些指标达到一个阈值就可以了,不需要特别的好；一个作为优化指标,意思是这个指标是我关注的重点指标,这个指标越高越好。<img src="/2018/08/24/结构化机器学习项目/2.jpg"><h2>训练集、验证集、测试集</h2>数据的划分一般有两种:较细致的一种是训练集、验证集和测试集;还有一种划分时训练集、测试集。划分的目的都是为了得到精确度最高、泛化能力最佳的模型。<h3>Training set</h3>通过设置不同的超参数、不同的模型,利用大量的训练数据来获得几个比较好的模型<h3>Dev set</h3>验证集的目的是**用来瞄准设定的预期目标**,不断向预期目标靠近,如果dev数据与实际应用数据差距较大,则瞄准的目标就出现了偏移,做的都是无用功。<h3>Test set </h3>通过训练集和验证集得到最优模型后,用测试集进一步验证所得到的模型，从而进一步确定该模型是否有较强的泛化能力。<font color="red">注意:要使验证集、测试集和以后要预测的目标来自同一分布。而训练集因为需要大量的数据所以不一定要求绝对来自同一分布。dev set 和 test set的数据要来自同一分布,不能让这两类数据分别从不同的地方取,并且最好的是能够取一些实际预测时的数据分别放入dev 和 test.当然,如果三个都能和实际应用时的数据来自同一分布当然最好。如果没有那么多的数据,一定要保证**验证集和测试集与实际应用测试数据来自同一分布**。因为训练集需要大量数据,可以适当用一些有较多数据的其他分布。<img src="/2018/08/24/结构化机器学习项目/3.jpg"></font><h3>训练集、验证集、测试集大小</h3><img src="/2018/08/24/结构化机器学习项目/4.jpg"><h2>偏差与方差</h2>在训练模型后,想要提升指标就需要进行分析是否出现了偏差、方差等问题。对于不同的问题要找出相应的解决方案。<h3>贝叶斯最佳误差</h3><img src="/2018/08/24/结构化机器学习项目/5.jpg">贝叶斯误差(最佳误差）计算机能达到的最优水平,一般与人类水平相似<font color="red">PS：训练集的准确度不一定要非常好,因为存在贝叶斯误差,所以达到一定理想水平就可以了。</font>**我们关注贝叶斯误差和人类误差主要是为了比较我们对训练集验证集测试集的错误率,来实时判断我们是需要降低方差还是降低偏差还是其他的方面**<h3>解决偏差的方法</h3><img src="/2018/08/24/结构化机器学习项目/6.jpg">当训练集误差和人类误差较大时:说明这时我们遇到了偏差问题   (1)可以训练更大的模型   (2)训练时间更长,或者选用更好的优化算法以获得更好的参数模型   (3)NN结构以及超参数搜索(改变超参数)当训练集误差和验证集误差较大时:方差问题   (1)需要更多的数据   (2)正则化 L2 or Dropout etc.   (3)NN结构以及超参数搜索(改变超参数)<h3>当训练集来自不同的分布</h3>当出现之前说的训练集与验证集来自不同分布的情况,如果迭代后的结果发现方差过大,原因有二:过拟合 or 来自不同分布method:首先将一部分train set 和 dev set 组装成新的train-dev set。对这个新数据的结果分析:train-dev set 大部分数据属于train set,和train set 是同分布,此时train set 与train-dev set之间的误差成为方差,train-dev set 与dev set之间成为数据不匹配 data mismatch,dev error 与test error 成为验证集的过拟合程度 degree of overfitting to dev set.然后根据结果得出是因为方差、偏差、还是数据不匹配;若是数据不匹配：   1.进行误差分析,分析dev set 和train set,找出两个分布差异的原因   2.尝试找一些与dev set 相似的数据,也可以采用人工数据合成的方法<h2>误差分析</h2>对**dev set进行误差分析**，取出一些错误的例子，人工统计分析不能拟合的原因。根据分析出来的几个问题选择重点问题寻找方法解决。如猫分类器的模型，分析出也许有很大比例的误差都是因为猫狗识别错误，就要特别针对猫狗识别来处理；如果大多数误差都是因为图片模糊，则要特别针对图像清晰度处理。**人工统计分析很重要，有必要花这个时间！！！**如下图：<img src="/2018/08/24/结构化机器学习项目/7.jpg"><h2>错误标签</h2>对于**训练集**，由于训练集数据很多,所以如果只是偶然的随机错误，一般不值得花费时间去修改。对于测试集和验证集，和误差分析一起统计，根据比例大小决定是否需要修正。如果确定要修正，建议： 1.一定要同时修改测试集和验证集 2.同时统计模型判断错的和没有判断出来的<h2>总结</h2><p>快速搭建一个系统：<br>1.快速找好训练集、验证集、测试集，设定好指标。尽快建立一个学习模型(输出层、代价函数不能忘)进行迭代（宁可之后再修改）。<br>2.<strong>再进行偏差方差分析、误差分析，找出重点问题具体分析解决，在解决的过程中注意要正交化(这才是重点)</strong></p><p></p><h1>多种学习方式的策略</h1><p></p><p></p><h2>迁移学习</h2><br><strong>迁移学习主要用于原对象有很多数据而迁移的对象没有大量数据的情况</strong><br>步骤:<br>1.首先可以仅仅改变一下神经网络的输出层或者最后几层<br>因为对于迁移学习来说,迁移对象两者之间是有关联的。正好神经网络的前几层是低层次的学习。比如猫狗识别与放射诊断的低层次特征是相似的,都是边缘检测、线条特征等等,这就是两个学习任务的共同知识,在迁移学习中就可以省略这些层数的重新训练。<br>2.如果训练结果不好可以逐渐训练前面的层数<p></p><p>train set 和 dev set来自不同分布在某种程度上就是一种迁移学习的影子。<br>例如猫分类器中,如果因为用户的低分辨率的图片数据较少,网络上的高分辨率的图片数据很多。低分辨率的图片其实是我们的理想数据,但是因为没有那么多数据,所以拿高分辨率的图片作为训练数据；这在某种程度上就可以理解为迁移学习,只不过这两者的关系及其紧密。</p><p></p><h2>多任务学习</h2><br>用单个神经网络训练多个问题(问题之间有关联),比如在一张图同时识别车、行人、交通信号灯等。<p></p><p>多任务学习的要求:<br>1.几个问题的低层次内容必须是一致的<br>2.每个问题都必须有大量的数据<br>3.深度学习模型要足够大<br>如果模型足够大,一般多任务学习会比分开单独的学习模型要好。</p><font color="red">多任务学习和迁移学习有点类似。但是最明显的区别是迁移学习的对象一个数据很多,另一个数据很少；而多任务学习要求每个问题的数据都很多。这就使得迁移学习的使用频率更高</font><p></p><h2>端到端的深度学习</h2><br>端到端的学习简化了学习系统,直接输入值然后就输出值。<br>多步骤的学习可以相对需要较少的数据去训练<br>优点: 简化了学习系统,省略了中间件。让模型自己去寻找解决方案,在某些问题上能够学习的比人设置的中间件更好。<br>缺点:<br>1.要求有大量的数据来训练<br>2.忽略了一些精心设计的非常好的中间件<p></p><p></p><h3>是否使用端到端的深度学习</h3><br>1.数据是否足够多<br>2.问题的复杂度(用端到端是否可行)<p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;h1&gt;前言&lt;/h1&gt;&lt;br&gt;本文是吴恩达deeplearning.ai 第三部分结构化机器学习项目学习笔记,&lt;strong&gt;&lt;em&gt;主要是在做项目时的策略总结&lt;/em&gt;&lt;/strong&gt;&lt;font color=&quot;red&quot;&gt;学习这一部分可以教你少走弯路,在何时应该选择什么样的策略使得自己的项目向着最好的方向发展。&lt;/font&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Deep Learning" scheme="https://statusrank.xyz/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow入门</title>
    <link href="https://statusrank.xyz/2018/08/16/TensorFlow%E5%85%A5%E9%97%A8/"/>
    <id>https://statusrank.xyz/2018/08/16/TensorFlow入门/</id>
    <published>2018-08-16T04:37:21.000Z</published>
    <updated>2018-08-23T10:55:36.722Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/geyunfei_/article/details/78782804" target="_blank" rel="noopener">本文部分转载自该大佬</a></p><p></p><h3>张量(Tensor)</h3><br>Tensorflow内部的计算都是基于张量的,因此我们有必要先对张量有个认识。张量是在我们熟悉的标量、向量之上定义的,详细的定义很复杂,我们可以先简单的将其理解为多维数组。<br><a id="more"></a><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>                                       # 这个 <span class="number">0</span> 阶张量就是标量，shape=[]</span><br><span class="line">[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>]                            # 这个 <span class="number">1</span> 阶张量就是向量，shape=[<span class="number">3</span>]</span><br><span class="line">[[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>], [<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>]]            # 这个 <span class="number">2</span> 阶张量就是二维数组，shape=[<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[[[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>]], [[<span class="number">7.</span>, <span class="number">8.</span>, <span class="number">9.</span>]]]        # 这个 <span class="number">3</span> 阶张量就是三维数组，shape=[<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p></p><p>TensorFlow内部使用tf.Tensor类的实例来表示张量,每个tf.Tensor具有两个属性:<br>dtype Tensor存储的数据类型,可以为tf.float32,tf.int32,tf.string。。。<br>shape Tensor存储的多维数组中每个维度的数组元素的个数.<br>我们现在可以敲几行代码看一下 Tensor 。在命令终端输入 python 或者 python3 启动一个 Python 会话，然后输入下面的代码：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 引入 tensorflow 模块</span><br><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line"># 创建一个整型常量，即 <span class="number">0</span> 阶 Tensor</span><br><span class="line">t0 = tf.constant(<span class="number">3</span>, dtype=tf.int32)</span><br><span class="line"></span><br><span class="line"># 创建一个浮点数的一维数组，即 <span class="number">1</span> 阶 Tensor</span><br><span class="line">t1 = tf.constant([<span class="number">3.</span>, <span class="number">4.1</span>, <span class="number">5.2</span>], dtype=tf.float32)</span><br><span class="line"></span><br><span class="line"># 创建一个字符串的<span class="number">2</span>x2数组，即 <span class="number">2</span> 阶 Tensor</span><br><span class="line">t2 = tf.constant(<span class="string">[['Apple', 'Orange'], ['Potato', 'Tomato']]</span>, dtype=tf.<span class="built_in">string</span>)</span><br><span class="line"></span><br><span class="line"># 创建一个 <span class="number">2</span>x3x1 数组，即 <span class="number">3</span> 阶张量，数据类型默认为整型</span><br><span class="line">t3 = tf.constant(<span class="string">[[[5], [6], [7]]</span>, <span class="string">[[4], [3], [2]]</span>])</span><br><span class="line"></span><br><span class="line"># 打印上面创建的几个 Tensor</span><br><span class="line"><span class="built_in">print</span>(t0)</span><br><span class="line"><span class="built_in">print</span>(t1)</span><br><span class="line"><span class="built_in">print</span>(t2)</span><br><span class="line"><span class="built_in">print</span>(t3)</span><br></pre></td></tr></table></figure></p><p>注意下面代码输出的shape类型:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(<span class="name">t0</span>)</span><br><span class="line">Tensor(<span class="string">"Const:0"</span>, shape=(), dtype=int32)</span><br><span class="line">&gt;&gt;&gt; print(<span class="name">t1</span>)</span><br><span class="line">Tensor(<span class="string">"Const_1:0"</span>, shape=(<span class="number">3</span>,), dtype=float32)</span><br><span class="line">&gt;&gt;&gt; print(<span class="name">t2</span>)</span><br><span class="line">Tensor(<span class="string">"Const_2:0"</span>, shape=(<span class="number">2</span>, <span class="number">2</span>), dtype=string)</span><br><span class="line">&gt;&gt;&gt; print(<span class="name">t3</span>)</span><br><span class="line">Tensor(<span class="string">"Const_3:0"</span>, shape=(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>), dtype=int32)</span><br></pre></td></tr></table></figure></p><font color="red">print一个Tensor只能打印出它的属性定义,并不能打印出他的值,要想查看一个Tensor中的值还需要经过Session运行一下</font><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sess = tf.Session()</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(sess.run(t0))</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(sess.run(t1))</span><br><span class="line">[ <span class="number">3.</span>          <span class="number">4.0999999</span>   <span class="number">5.19999981</span>]</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(sess.run(t2))</span><br><span class="line"><span class="string">[[b'Apple' b'Orange']</span></span><br><span class="line"><span class="string"> [b'Potato' b'Tomato']]</span></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(sess.run(t3))</span><br><span class="line"><span class="string">[[[5]</span></span><br><span class="line"><span class="string">  [6]</span></span><br><span class="line"><span class="string">  [7]]</span></span><br><span class="line"></span><br><span class="line"> <span class="string">[[4]</span></span><br><span class="line"><span class="string">  [3]</span></span><br><span class="line"><span class="string">  [2]]</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p></p><h3>数据流图(Dataflow Graph)</h3><br>数据流是一种常见的并行计算编程模型,数据流图是由结点(nodes)和线(edges)构成的有向图:<br>节点(nodes) 表示计算单元，也可以是输入的起点或者输出的终点<br>线(edges) 表示节点之间的输入/输出关系.<br>在TensorFlow中每个结点都是用tf.Tensor的实例来表示的,即每个节点的输入、输出都是Tensor,如图,Tensor在Graph中流动,形象的展示TensorFlow的由来<br><img src="/2018/08/16/TensorFlow入门/1.gif"><p></p><p></p><h3>Session</h3><br>我们在Python中需要做一些计算操作时一般会使用NumPy，NumPy在做矩阵操作等复杂的计算的时候会使用其他语言(C/C++)来实现这些计算逻辑，来保证计算的高效性。但是频繁的在多个编程语言间切换也会有一定的耗时，如果只是单机操作这些耗时可能会忽略不计，但是如果在分布式并行计算中，计算操作可能分布在不同的CPU、GPU甚至不同的机器中，这些耗时可能会比较严重。<br>TensorFlow 底层是使用C++实现，这样可以保证计算效率，并使用 tf.Session类来连接客户端程序与C++运行时。上层的Python、Java等代码用来设计、定义模型，构建的Graph，最后通过tf.Session.run()方法传递给底层执行。<p></p><p></p><h3>构建计算图</h3><br>Tensor 可以表示输入、输出的端点,还可以表示计算单元,如下的代码创建了对两个Tensor执行+操作:<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"><span class="comment"># 创建两个常量节点</span></span><br><span class="line">node1 = tf.constant(3.2)</span><br><span class="line">node2 = tf.constant(4.8)</span><br><span class="line"><span class="comment"># 创建一个 adder 节点，对上面两个节点执行 + 操作</span></span><br><span class="line">adder = node1 + node2</span><br><span class="line"><span class="comment"># 打印一下 adder 节点</span></span><br><span class="line">print(adder)</span><br><span class="line"><span class="comment"># 打印 adder 运行后的结果</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line">print(sess.run(adder))</span><br></pre></td></tr></table></figure><p></p><p>输出为:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Tensor</span><span class="params">(<span class="string">"add:0"</span>, shape=()</span></span>, dtype=float32)</span><br><span class="line"><span class="number">8.0</span></span><br></pre></td></tr></table></figure></p><p>上面使用的tf.constant()创建的Tensor都是常量,一旦创建后其中的值就不能在改变了.但是有时我们还会需要从外部输入数据,这时可以用tf.placeholder创建占位的Tensor,占位Tensor的值可以在运行的时候输入。例如:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"><span class="comment"># 创建两个占位 Tensor 节点</span></span><br><span class="line">a = tf.placeholder(tf.float32)</span><br><span class="line">b = tf.placeholder(tf.float32)</span><br><span class="line"><span class="comment"># 创建一个 adder 节点，对上面两个节点执行 + 操作</span></span><br><span class="line">adder_node = a + b</span><br><span class="line"><span class="comment"># 打印三个节点</span></span><br><span class="line"><span class="builtin-name">print</span>(a)</span><br><span class="line"><span class="builtin-name">print</span>(b)</span><br><span class="line"><span class="builtin-name">print</span>(adder)</span><br><span class="line"><span class="comment"># 运行一下，后面的 dict 参数是为占位 Tensor 提供输入数据</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line"><span class="builtin-name">print</span>(sess.<span class="builtin-name">run</span>(adder, &#123;a: 3, b: 4.5&#125;))</span><br><span class="line"><span class="builtin-name">print</span>(sess.<span class="builtin-name">run</span>(adder, &#123;a: [1, 3], b: [2, 4]&#125;))</span><br></pre></td></tr></table></figure></p><p>运行结果:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Tensor</span><span class="params">(<span class="string">"Placeholder:0"</span>, dtype=float32)</span></span></span><br><span class="line"><span class="function"><span class="title">Tensor</span><span class="params">(<span class="string">"Placeholder_1:0"</span>, dtype=float32)</span></span></span><br><span class="line"><span class="function"><span class="title">Tensor</span><span class="params">(<span class="string">"add:0"</span>, dtype=float32)</span></span></span><br><span class="line"><span class="number">7.5</span></span><br><span class="line">[ <span class="number">3</span>.  <span class="number">7</span>.]</span><br></pre></td></tr></table></figure></p><p></p><h2>TensorFlow 应用实例<br>下面通过一个例子来了解下TensorFlow。<p></p><p></p><h3>建立模型</h3><br>如下为我们进行某项实验获得的一些实验数据：<p></p><p>输入    输出<br>1    4.8<br>2    8.5<br>3    10.4<br>6    21<br>8    25.3<br>我们将这些数据放到一个二维图上可以看的更直观一些，如下，这些数据在图中表现为一些离散的点：<br><img src="/2018/08/16/TensorFlow入门/2.png"><br>我们需要根据现有的这些数据归纳出一个通用模型，通过这个模型我们可以预测其他的输入值产生的输出值。假设我们现在选择一个线性模型来拟合这些数据。如果用 x 表示输入， y 表示输出，线性模型可以用下面的方程表示： $ y = Wx + b$<br>即使我们选择了直线模型，可以选择的模型也会有很多，如下图的三条直线都像是一种比较合理的模型，只是W和b参数不同。这时我们需要设计一个损失模型(loss model)，来评估一下哪个模型更合理一些，并找到一个最准确的模型。<br> <img src="/2018/08/16/TensorFlow入门/3.png"><br>如下图每条黄线代表线性模型计算出来的值与实际输出值之间的差值:<br><img src="/2018/08/16/TensorFlow入门/4.png"><br>我们用y′表示实验得到的实际输出，用下面的方程表示我们的损失模型：<br>$ loss = \sum_{n = 1}^N (y_n - y_n’)^2 $<br>显然，损失模型里得到的loss越小，说明我们的线性模型越准确。</p><p></p><h3>使用Tensorflow实现模型</h3><br>在我们设计的模型$ y = Wx + b$中 x是我们输入的值,所以可以使用tf.placeholder 来实现。输出y可以用线性模型的输出表示,我们需要不断的改变W和b的值,来找到一个使loss最小的值。这里W和b可以用变量tf.Variable()来表示。<p></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"><span class="comment"># 创建变量 W 和 b 节点，并设置初始值</span></span><br><span class="line">W = tf.Variable([.1], dtype=tf.float32)</span><br><span class="line">b = tf.Variable([-.1], dtype=tf.float32)</span><br><span class="line"><span class="comment"># 创建 x 节点，用来输入实验中的输入数据</span></span><br><span class="line">x = tf.placeholder(tf.float32)</span><br><span class="line"><span class="comment"># 创建线性模型</span></span><br><span class="line">linear_model = W*x + b</span><br><span class="line"><span class="comment"># 创建 y 节点，用来输入实验中得到的输出数据，用于损失模型计算</span></span><br><span class="line">y = tf.placeholder(tf.float32)</span><br><span class="line"><span class="comment"># 创建损失模型</span></span><br><span class="line">loss = tf.reduce_sum(tf.square(linear_model - y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Session 用来计算模型</span></span><br><span class="line">sess = tf.Session()</span><br></pre></td></tr></table></figure><p>通过tf.Variable()创建变量Tensor时需要设置一个初始值,这个初始值不能立即使用必须通过init过程进行初始化。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化变量</span></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line">sess.run(init)</span><br></pre></td></tr></table></figure><p>这之后再使用print(sess.run(W))打印就可以看到我们之前赋的初始值<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0.1</span>]</span><br></pre></td></tr></table></figure></p><p>变量初始化完之后，我们可以先用上面对W和b设置的初始值0.1和-0.1运行一下我们的线性模型看看结果：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">print</span>(<span class="selector-tag">sess</span><span class="selector-class">.run</span>(<span class="selector-tag">linear_model</span>, &#123;<span class="attribute">x</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>]&#125;))</span><br></pre></td></tr></table></figure></p><p>输出结果为：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="number">0.</span>          <span class="number">0.1</span>         <span class="number">0.20000002</span>  <span class="number">0.5</span>         <span class="number">0.69999999</span>]</span><br></pre></td></tr></table></figure></p><p></p><h3>使用Tensorflow训练模型</h3><br>Tensorflow提供了很多优化算法来帮助我们训练模型,最简单的就是Gradient Descent.<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个梯度下降优化器,学习率为0.001</span></span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(0.001)</span><br><span class="line">train = optimizer.minimize(loss)</span><br><span class="line"><span class="comment"># 用两个数组保存训练数据</span></span><br><span class="line">x_train = [1, 2, 3, 6, 8]</span><br><span class="line">y_train = [4.8, 8.5, 10.4, 21.0, 25.3]</span><br><span class="line"><span class="comment"># 训练10000次</span></span><br><span class="line">for i in range(10000):</span><br><span class="line">    sess.run(train, &#123;x: x_train, y: y_train&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印一下训练后的结果</span></span><br><span class="line"><span class="section">print('W: %s b: %s loss: %s' % (sess.run(W), sess.run(b), sess.run(loss, &#123;x: x_train , y: y_train&#125;)))</span></span><br></pre></td></tr></table></figure><p></p><p>打印出来的训练结果如下，可以看到损失值已经很小了：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">W</span>: <span class="selector-attr">[ 2.98236108]</span> <span class="selector-tag">b</span>: <span class="selector-attr">[ 2.07054377]</span> <span class="selector-tag">loss</span>: 2<span class="selector-class">.12941</span></span><br></pre></td></tr></table></figure></p></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/geyunfei_/article/details/78782804&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本文部分转载自该大佬&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3&gt;张量(Tensor)&lt;/h3&gt;&lt;br&gt;Tensorflow内部的计算都是基于张量的,因此我们有必要先对张量有个认识。张量是在我们熟悉的标量、向量之上定义的,详细的定义很复杂,我们可以先简单的将其理解为多维数组。&lt;br&gt;
    
    </summary>
    
    
      <category term="Deep Learning" scheme="https://statusrank.xyz/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>deeplearning.ai 改善深度神经网络(正则化、优化、mini-batch等)</title>
    <link href="https://statusrank.xyz/2018/08/15/%E6%94%B9%E5%96%84%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>https://statusrank.xyz/2018/08/15/改善深度神经网络/</id>
    <published>2018-08-15T03:09:42.000Z</published>
    <updated>2018-08-15T14:21:54.704Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/statusrank/deeplearning.ai-note" target="_blank" rel="noopener">作业地址可查看github</a></p><h2>一、初始化</h2><h3>1.为什么神经网络的所有参数不能全部初始化为0>?</h3>若w初始化为0 ,很可能导致模型失效,无法收敛。也就是说如果我们初始将所有的w初始化为0,那么进行前向传播时每一层得到的值都是一样,这样一来当我们使用反向传播时,传回的梯度也是一样的,这就导致了我们更新参数后w还是一样的,这就使得我们的NN不能各自学习到很好的特征了。[可以看这里](https://zhuanlan.zhihu.com/p/27190255)<a id="more"></a><h3>2.Xavier Initialization</h3>  Xavier Initialization 初始化的基本思想就是保持输入和输出的方差一致,这样就避免了所有的输出值趋向于0.  首先对于前向传播,我们需要确保所有层的激活值方差近似相等,因此每个训练样本传播经过网络的信息才能保持平滑的属性。同样对于反向传播,每层梯度保持近似的方差将允许信息平滑地反向流动以更新权重。近似方差的梯度同样确保误差数据能够反馈到所有层级,因此它是整个训练中的关键。[这位大佬写的很不错](https://www.jiqizhixin.com/articles/2018-01-08-3)将W的方差变为 $ \frac{1}{layersdims[l - 1]} $<h3>3.He Initialization</h3>He Initialization 在使用Relu作为非线性激活函数时具有更好的效果,因为Relu函数将所有的负数都变为0,所以W的整体的方差需要变为原来的二倍，$ \\frac{2}{layersdims[l - 1]} $<h2>二、正则化</h2><h3>1.什么是过拟合(overfitting)?</h3>过拟合就是指在我们的训练数据中存在一些噪声,而我们的模型拟合的很好将这些噪声也都给拟合进去了,使我们的分类器过于严格。这时候我们得到的参数往往就对我们的train data表现的很好,对其他数据表现的很差。<h3>2.L2 Regularization</h3>L2正则化,又叫L2范式。基本格式: $ \frac{\lambda}{2}\sum_i^{m} W_i^2 $ (除2是为了求导时抵消)也就是把我们所有的参数,都加入一个平方的乘法项，因为加入了平方惩罚项,所以在进行拟合时我们使得所有得到的参数都比较小,我们一般认为参数小的模型都比较简单可以适应不同的数据集,从而一定程度上避免了过拟合。但是同时这里也增加了一个超参数 $ \lambda $<h3>3.Dropout</h3>Dropout在深度学习中是一种广泛使用的技术。在每一层中,他会以一定的概率使一些神经元停止工作,这样使得各个神经元之间不相互依赖,从而提高模型的泛化能力。每一个神经元有一个将其保留下来的概率,keep_prob(每一层的概率不一定相同)，那么当你在进行每一次迭代的时候对每一层的每个神经元你都有一定的概率(1 - keep_prob)，也就是将其激活值置为0,停止的神经元对后面的前向传播和反向传播不起作用。<font color="red">注意在输入和输出层我们不需要使用dropout</font>Dropout的实现:  (1) 通过np.random.randn()初始化一个和A^L 一样的矩阵,并将此看为把每个神经元保留的概率  (2) D = (D <= keep_prob)="" (3)="" a="A" *="" d="" (数乘,一一对应)="" (4)="" $="" 通过这一步使得loss的期望值和没有dropout时是一样的="" 与此同时,在进行反向传播时也需要做同样的操作="" <font="" color="red">使用Dropout需要注意以下几点:  Dropout是一种正则化技术  只是在训练阶段使用dropout,在test时不要使用  记得需要除以 keep_prob从而使得期望值不变<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GRADED FUNCTION: forward_propagation_with_dropout</span></span><br><span class="line"></span><br><span class="line">def forward_propagation_with_dropout(X, parameters, <span class="attr">keep_prob</span> = <span class="number">0.5</span>):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    Implements the forward propagation: LINEAR -&gt; RELU + DROPOUT -&gt; LINEAR -&gt; RELU + DROPOUT -&gt; LINEAR -&gt; SIGMOID.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    X -- input dataset, of shape (2, number of examples)</span></span><br><span class="line"><span class="string">    parameters -- python dictionary containing your parameters "</span>W1<span class="string">", "</span>b1<span class="string">", "</span>W2<span class="string">", "</span>b2<span class="string">", "</span>W3<span class="string">", "</span>b3<span class="string">":</span></span><br><span class="line"><span class="string">                    W1 -- weight matrix of shape (20, 2)</span></span><br><span class="line"><span class="string">                    b1 -- bias vector of shape (20, 1)</span></span><br><span class="line"><span class="string">                    W2 -- weight matrix of shape (3, 20)</span></span><br><span class="line"><span class="string">                    b2 -- bias vector of shape (3, 1)</span></span><br><span class="line"><span class="string">                    W3 -- weight matrix of shape (1, 3)</span></span><br><span class="line"><span class="string">                    b3 -- bias vector of shape (1, 1)</span></span><br><span class="line"><span class="string">    keep_prob - probability of keeping a neuron active during drop-out, scalar</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    A3 -- last activation value, output of the forward propagation, of shape (1,1)</span></span><br><span class="line"><span class="string">    cache -- tuple, information stored for computing the backward propagation</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    </span><br><span class="line">    np.random.seed(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># retrieve parameters</span></span><br><span class="line">    <span class="attr">W1</span> = parameters['W1']</span><br><span class="line">    <span class="attr">b1</span> = parameters['b1']</span><br><span class="line">    <span class="attr">W2</span> = parameters['W2']</span><br><span class="line">    <span class="attr">b2</span> = parameters['b2']</span><br><span class="line">    <span class="attr">W3</span> = parameters['W3']</span><br><span class="line">    <span class="attr">b3</span> = parameters['b3']</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># LINEAR -&gt; RELU -&gt; LINEAR -&gt; RELU -&gt; LINEAR -&gt; SIGMOID</span></span><br><span class="line">    <span class="attr">Z1</span> = np.dot(W1, X) + b1</span><br><span class="line">    <span class="attr">A1</span> = relu(Z1)</span><br><span class="line">    <span class="comment">### START CODE HERE ### (approx. 4 lines)         # Steps 1-4 below correspond to the Steps 1-4 described above. </span></span><br><span class="line">    <span class="attr">D1</span> = np.random.rand(A1.shape[<span class="number">0</span>],A1.shape[<span class="number">1</span>])    <span class="comment"># Step 1: initialize matrix D1 = np.random.rand(..., ...)</span></span><br><span class="line">    <span class="attr">D1</span> = (D1 &lt;= keep_prob)                              <span class="comment"># Step 2: convert entries of D1 to 0 or 1 (using keep_prob as the threshold)</span></span><br><span class="line">    <span class="attr">A1</span> = A1 * D1                                   <span class="comment"># Step 3: shut down some neurons of A1</span></span><br><span class="line">    <span class="attr">A1</span> = A1 / keep_prob                               <span class="comment"># Step 4: scale the value of neurons that haven't been shut down</span></span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    <span class="attr">Z2</span> = np.dot(W2, A1) + b2</span><br><span class="line">    <span class="attr">A2</span> = relu(Z2)</span><br><span class="line">    <span class="comment">### START CODE HERE ### (approx. 4 lines)</span></span><br><span class="line">    <span class="attr">D2</span> = np.random.rand(A2.shape[<span class="number">0</span>],A2.shape[<span class="number">1</span>])     <span class="comment"># Step 1: initialize matrix D2 = np.random.rand(..., ...)</span></span><br><span class="line">    <span class="attr">D2</span> = (D2 &lt;= keep_prob)                              <span class="comment"># Step 2: convert entries of D2 to 0 or 1 (using keep_prob as the threshold)</span></span><br><span class="line">    <span class="attr">A2</span> = A2 * D2                                    <span class="comment"># Step 3: shut down some neurons of A2</span></span><br><span class="line">    <span class="attr">A2</span> = A2 / keep_prob                              <span class="comment"># Step 4: scale the value of neurons that haven't been shut down</span></span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    <span class="attr">Z3</span> = np.dot(W3, A2) + b3</span><br><span class="line">    <span class="attr">A3</span> = sigmoid(Z3)</span><br><span class="line">    </span><br><span class="line">    <span class="attr">cache</span> = (Z1, D1, A1, W1, b1, Z2, D2, A2, W2, b2, Z3, A3, W3, b3)</span><br><span class="line">    </span><br><span class="line">    return A3, cache</span><br></pre></td></tr></table></figure><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GRADED FUNCTION: backward_propagation_with_dropout</span></span><br><span class="line"></span><br><span class="line">def backward_propagation_with_dropout(X, Y, cache, keep_prob):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    Implements the backward propagation of our baseline model to which we added dropout.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    X -- input dataset, of shape (2, number of examples)</span></span><br><span class="line"><span class="string">    Y -- "</span><span class="literal">true</span><span class="string">" labels vector, of shape (output size, number of examples)</span></span><br><span class="line"><span class="string">    cache -- cache output from forward_propagation_with_dropout()</span></span><br><span class="line"><span class="string">    keep_prob - probability of keeping a neuron active during drop-out, scalar</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    gradients -- A dictionary with the gradients with respect to each parameter, activation and pre-activation variables</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">m</span> = X.shape[<span class="number">1</span>]</span><br><span class="line">    (Z1, D1, A1, W1, b1, Z2, D2, A2, W2, b2, Z3, A3, W3, b3) = cache</span><br><span class="line">    </span><br><span class="line">    <span class="attr">dZ3</span> = A3 - Y</span><br><span class="line">    <span class="attr">dW3</span> = <span class="number">1</span>./m * np.dot(dZ3, A2.T)</span><br><span class="line">    <span class="attr">db3</span> = <span class="number">1</span>./m * np.sum(dZ3, <span class="attr">axis=1,</span> <span class="attr">keepdims</span> = True)</span><br><span class="line">    <span class="attr">dA2</span> = np.dot(W3.T, dZ3)</span><br><span class="line">    <span class="comment">### START CODE HERE ### (≈ 2 lines of code)</span></span><br><span class="line">    <span class="attr">dA2</span> = dA2 * D2 <span class="comment"># Step 1: Apply mask D2 to shut down the same neurons as during the forward propagation</span></span><br><span class="line">    <span class="attr">dA2</span> = dA2 / keep_prob       <span class="comment"># Step 2: Scale the value of neurons that haven't been shut down</span></span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    <span class="attr">dZ2</span> = np.multiply(dA2, np.int64(A2 &gt; <span class="number">0</span>))</span><br><span class="line">    <span class="attr">dW2</span> = <span class="number">1</span>./m * np.dot(dZ2, A1.T)</span><br><span class="line">    <span class="attr">db2</span> = <span class="number">1</span>./m * np.sum(dZ2, <span class="attr">axis=1,</span> <span class="attr">keepdims</span> = True)</span><br><span class="line">    </span><br><span class="line">    <span class="attr">dA1</span> = np.dot(W2.T, dZ2)</span><br><span class="line">    <span class="comment">### START CODE HERE ### (≈ 2 lines of code)</span></span><br><span class="line">    <span class="attr">dA1</span> = dA1 * D1              <span class="comment"># Step 1: Apply mask D1 to shut down the same neurons as during the forward propagation</span></span><br><span class="line">    <span class="attr">dA1</span> = dA1 / keep_prob             <span class="comment"># Step 2: Scale the value of neurons that haven't been shut down</span></span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    <span class="attr">dZ1</span> = np.multiply(dA1, np.int64(A1 &gt; <span class="number">0</span>))</span><br><span class="line">    <span class="attr">dW1</span> = <span class="number">1</span>./m * np.dot(dZ1, X.T)</span><br><span class="line">    <span class="attr">db1</span> = <span class="number">1</span>./m * np.sum(dZ1, <span class="attr">axis=1,</span> <span class="attr">keepdims</span> = True)</span><br><span class="line">    </span><br><span class="line">    <span class="attr">gradients</span> = &#123;<span class="string">"dZ3"</span>: dZ3, <span class="string">"dW3"</span>: dW3, <span class="string">"db3"</span>: db3,<span class="string">"dA2"</span>: dA2,</span><br><span class="line">                 <span class="string">"dZ2"</span>: dZ2, <span class="string">"dW2"</span>: dW2, <span class="string">"db2"</span>: db2, <span class="string">"dA1"</span>: dA1, </span><br><span class="line">                 <span class="string">"dZ1"</span>: dZ1, <span class="string">"dW1"</span>: dW1, <span class="string">"db1"</span>: db1&#125;</span><br><span class="line">    </span><br><span class="line">    return gradients</span><br></pre></td></tr></table></figure><h2>三、优化</h2><h3>1.Mini_batch Gradient descent</h3><p>1.首先需要介绍Batch gradient descent，即完全采用全数据集的形式,由全数据集确定的方向能更好的代表样本总体,从而更准确的朝极值的方向。但是由于数据的海量增长和内存的限制,一次性载入全部的数据变得异常困难。<br>2.stochastic gradient descent，随机梯度下降,每次只采用一个样本进行梯度下降。这大大减少了训练时间,但是以每个样本各自的梯度方向修正,横冲直撞各自为政很难最后达到收敛。<br>3.这时候就产生了Mini——batch gradient descent.他是介于Batch gradient descent 和stochastic gradient descent之间的一种方法。当数据量很小时,我们直接采用Batch gradient descent ,当数据量很大时我们采用mini-batch,这时候每一个mini-batch的大小,我们称为batch_size。<br>其实当batch_size = m 就是batch gradient descent ,batch_size = 1 就是stochastic gradient descent.</p><p>常用的batch——size大小为: 64,128,256,512 一般为2的幂。</p><h4>为什么mini-batch有优势?</h4>假设我们现在有100万样本,如果我们采用batch gradient descent 遍历一次所有的数据(epoch)只进行了一次迭代,如果我们将整个样本分成1000份,也就是batch_size = 1000,则会有1000个子集,然后当我们用for循环遍历这些子集时,针对每个子集进行一次梯度下降,这样当遍历完所有样本一次(epoch)我们相当于在梯度下降中进行了1000次迭代,这样就大大提高了我们算法的速度,同时因为每个子集只有1000个样本,也提高了内存的利用率。<h4>mini_batch 的效果</h4><img src="/2018/08/15/改善深度神经网络/2.png">如上图，左边是full batch的梯度下降效果。 可以看到每一次迭代成本函数都呈现下降趋势，这是好的现象，说明我们w和b的设定一直再减少误差。 这样一直迭代下去我们就可以找到最优解。 右边是mini batch的梯度下降效果，可以看到它是上下波动的，成本函数的值有时高有时低,但是总体呈现下降的趋势。这个也是正常的,<font color="red">因为我们每一次梯度下降都是在mini_batch 上跑的而不是在整个数据集上,所以数据的差异可能会导致这样的效果，可能某段数据效果特别好,m藕断数据效果不好,但是他总体还是呈现下降趋势的。</font><img src="/2018/08/15/改善深度神经网络/1.png"><font color="red">对于batch_size大小的选择，我们不能太大,因为太大会接近full batch的行为;也不能太小,太小了可能算法永远不会收敛。</font><h4>mini_batch 实现</h4><p>(1)为了避免偶然性,我们需要打乱我们的train data,通过np.random.permutation()随机打乱下标,并保存为list. 然后根据列表值重新获得矩阵.<br>(2)根据batch_size 大小进行划分.注意不能除尽的情况</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GRADED FUNCTION: random_mini_batches</span></span><br><span class="line"></span><br><span class="line">def random_mini_batches(X, Y, <span class="attr">mini_batch_size</span> = <span class="number">64</span>, <span class="attr">seed</span> = <span class="number">0</span>):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    Creates a list of random minibatches from (X, Y)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    X -- input data, of shape (input size, number of examples)</span></span><br><span class="line"><span class="string">    Y -- true "</span>label<span class="string">" vector (1 for blue dot / 0 for red dot), of shape (1, number of examples)</span></span><br><span class="line"><span class="string">    mini_batch_size -- size of the mini-batches, integer</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    mini_batches -- list of synchronous (mini_batch_X, mini_batch_Y)</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    </span><br><span class="line">    np.random.seed(seed)            <span class="comment"># To make your "random" minibatches the same as ours</span></span><br><span class="line">    <span class="attr">m</span> = X.shape[<span class="number">1</span>]                  <span class="comment"># number of training examples</span></span><br><span class="line">    <span class="attr">mini_batches</span> = []</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># Step 1: Shuffle (X, Y)</span></span><br><span class="line">    <span class="attr">permutation</span> = list(np.random.permutation(m)) <span class="comment"># 随机打乱数组,permutation 参数可以是int,返回一个list</span></span><br><span class="line">    <span class="attr">shuffled_X</span> = X[:, permutation]    <span class="comment"># 按照permutation列表中的数字顺序作为下标重新得到一个列表,从而实现打乱矩阵的功能</span></span><br><span class="line">    <span class="attr">shuffled_Y</span> = Y[:, permutation].reshape((<span class="number">1</span>,m))</span><br><span class="line">    <span class="comment"># Step 2: Partition (shuffled_X, shuffled_Y). Minus the end case.</span></span><br><span class="line">    <span class="attr">num_complete_minibatches</span> = math.floor(m/mini_batch_size) <span class="comment"># number of mini batches of size mini_batch_size in your partitionning</span></span><br><span class="line">    for k <span class="keyword">in</span> range(<span class="number">0</span>, num_complete_minibatches):</span><br><span class="line">        <span class="comment">### START CODE HERE ### (approx. 2 lines)</span></span><br><span class="line">        <span class="attr">mini_batch_X</span> = shuffled_X[:,k * mini_batch_size : (k + <span class="number">1</span>) * mini_batch_size]</span><br><span class="line">        <span class="attr">mini_batch_Y</span> = shuffled_Y[:,k * mini_batch_size : (k + <span class="number">1</span>) * mini_batch_size]</span><br><span class="line">        <span class="comment">### END CODE HERE ###</span></span><br><span class="line">        <span class="attr">mini_batch</span> = (mini_batch_X, mini_batch_Y)</span><br><span class="line">        mini_batches.append(mini_batch)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Handling the end case (last mini-batch &lt; mini_batch_size)</span></span><br><span class="line">    <span class="keyword">if</span> m % mini_batch_size != <span class="number">0</span>:</span><br><span class="line">        <span class="comment">### START CODE HERE ### (approx. 2 lines)</span></span><br><span class="line">        <span class="attr">mini_batch_X</span> = shuffled_X[:,num_complete_minibatches * mini_batch_size : m]</span><br><span class="line">        <span class="attr">mini_batch_Y</span> = shuffled_Y[:,num_complete_minibatches * mini_batch_size : m]</span><br><span class="line">        <span class="comment">### END CODE HERE ###</span></span><br><span class="line">        <span class="attr">mini_batch</span> = (mini_batch_X, mini_batch_Y)</span><br><span class="line">        mini_batches.append(mini_batch)</span><br><span class="line">    </span><br><span class="line">    return mini_batches</span><br></pre></td></tr></table></figure><p></p><h3>2.momentum动量</h3><br>因为mini_bacth梯度下降使参数每次只在子集上更新自己的参数,所以它每次下降的方向会有很多抖动,也就是说梯度下降会很大幅度的变动徘徊这向最低点前进(convergence 收敛)。使用momentum可以减少相应的抖动。<br>momentum会把过去的梯度考虑在内，使得梯度变的更平滑.<br><img src="/2018/08/15/改善深度神经网络/3.png"><p></p><p></p><h4>指数加权平均</h4><br>举例说明，下面是一个同学的某一科的考试成绩：<br>平时测验 80， 期中 90， 期末 95<br>学校规定的科目成绩的计算方式是：<br>平时测验占 20%；<br>期中成绩占 30%；<br>期末成绩占 50%；<br>这里，每个成绩所占的比重叫做权数或权重。那么，<br>加权平均值 = $80×0.2 + 90×0.3 + 95×0.5 = 90.5$<br>算数平均值 = (80 + 90 + 95)/3 = 88.3<br>另外一个例子,我们需要计算某地温度的移动平均值。<br>我们现在先直接给出一个公式 $V<em>t = \beta*V</em>{t-1} + (1 - \beta) \theta_t$ 其中$V_t$表示到第t天的平均温度值, $ \theta_t$ 表示第t填的温度值,$\beta$是可调节的超参数。<br>假设现在$\beta$值为0.9，那么大体就是前一日的v加上 0.1的今天的温度,对此我们可以理解为V的指数加权平均值约等于 $\frac{1}{1 - \beta} $ 也就是说大哥 $\beta$ = 0.9 就是温度十天以来的加权平均值,$ \beta$ = 0.98就是50天以内的温度加权平均值.<br><img src="/2018/08/15/改善深度神经网络/4.png"><br>通过上面的表达式我们可以知道,$V_100$ 等于每天的温度乘以一个权值,本质就是以指数形式递减加权的移动平均,各数值的加权随时间而指数式递减,越近期的数据加权越重,而我们的算数平均每一项的权值都是 $\frac{1}{n}$<p></p><p></p><h4>偏差修正</h4><br>首先给出带偏差修正的指数加权平均公式:<br>$V<em>t = \beta V</em>{t-1} + (1-\beta)\theta<em>{t}$<br>$\hat(V_t) = \frac{V_t}{1-\beta^t} = \frac{\beta V</em>{t-1} + (1-\beta)\theta_t}{1-\beta^t} $<br>随着t的增大,$ \beta^t $逐渐趋近于0,从而偏差修正不在起作用。<br>实际上,上面的例子在 $\beta = 0.98$时,实际上我们得到的不是绿色曲线,而是紫色曲线,因为使用指数加权平均的方法在前期会有很大的偏差,为此我们引入了偏差修正的概念。<br><img src="/2018/08/15/改善深度神经网络/6.png"><p></p><font color="red">在机器学习中,在计算指数加权平均数的大部分时候,大家不太在乎偏差修正,大部分宁愿熬过初始阶段,拿到具有偏差的估测,然后继续计算下去.如果你关心初始时期的偏差,修正偏差能帮助你在早期获得更好的估测</font><p></p><h4>momentum公式</h4><br>以前我们在进行梯度下降时,对参数W更新, $ W = W - \alpha dw $,由于我们前面说过梯度下降会有很多抖动,所以这里我们就是在更新W的时候做些手脚。<br>$ V<em>{dw} = \beta V</em>{dw} + (1 - \beta)dw$<br>$ W = W - \alpha V<em>{dw}$<br>$V</em>{db} = \beta V<em>{db} + (1-beta)db $<br>$b = b - \alpha V</em>{db}$<p></p><p>$V<em>{dw},V</em>{db}$ 表示对w的导数dw,b的导数db求指数加权平均,然后更新参数时减去的是指数加权平均的值而不是导数的值。<br>关于 $ \beta$的值的选择,我们选择的值越大则结果越平滑,因为对过去的权重占的越多,对自己本身占的少,但是如果很大就超出我们想要的效果了。所以一般我们取 $\beta$ = 0.9</p><p>效果如图:<img src="/2018/08/15/改善深度神经网络/7.png"><br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># GRADED FUNCTION: update_parameters_with_momentum</span><br><span class="line"></span><br><span class="line">def update_parameters_with_momentum(parameters, grads, v, beta, learning_rate):</span><br><span class="line">    <span class="string">""</span><span class="comment">"</span></span><br><span class="line">    Update parameters using Momentum</span><br><span class="line">    </span><br><span class="line">    Argument<span class="variable">s:</span></span><br><span class="line">    parameters -- <span class="keyword">python</span> dictionary containing your parameter<span class="variable">s:</span></span><br><span class="line">                    parameters[<span class="string">'W'</span> + str(<span class="keyword">l</span>)] = Wl</span><br><span class="line">                    parameters[<span class="string">'b'</span> + str(<span class="keyword">l</span>)] = <span class="keyword">bl</span></span><br><span class="line">    grads -- <span class="keyword">python</span> dictionary containing your gradients <span class="keyword">for</span> each parameter<span class="variable">s:</span></span><br><span class="line">                    grads[<span class="string">'dW'</span> + str(<span class="keyword">l</span>)] = dWl</span><br><span class="line">                    grads[<span class="string">'db'</span> + str(<span class="keyword">l</span>)] = dbl</span><br><span class="line">    v -- <span class="keyword">python</span> dictionary containing the current velocity:</span><br><span class="line">                    v[<span class="string">'dW'</span> + str(<span class="keyword">l</span>)] = ...</span><br><span class="line">                    v[<span class="string">'db'</span> + str(<span class="keyword">l</span>)] = ...</span><br><span class="line">    beta -- the momentum hyperparameter, scalar</span><br><span class="line">    learning_rate -- the learning rate, scalar</span><br><span class="line">    </span><br><span class="line">    Return<span class="variable">s:</span></span><br><span class="line">    parameters -- <span class="keyword">python</span> dictionary containing your updated parameters </span><br><span class="line">    v -- <span class="keyword">python</span> dictionary containing your updated velocities</span><br><span class="line">    <span class="string">""</span><span class="comment">"</span></span><br><span class="line"></span><br><span class="line">    L = <span class="built_in">len</span>(parameters) // <span class="number">2</span> # <span class="keyword">number</span> of layers in the neural networks</span><br><span class="line">    </span><br><span class="line">    # Momentum <span class="keyword">update</span> <span class="keyword">for</span> each parameter</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">l</span> in <span class="built_in">range</span>(L):</span><br><span class="line">        </span><br><span class="line">        ### START CODE HERE ### (approx. <span class="number">4</span> lines)</span><br><span class="line">        # compute velocities</span><br><span class="line">        v[<span class="string">'dW'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] = beta * v[<span class="string">'dW'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] + (<span class="number">1</span>. - beta) * grads[<span class="string">'dW'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)]</span><br><span class="line">        v[<span class="string">'db'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] = beta * v[<span class="string">'db'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] + (<span class="number">1</span>. - beta) * grads[<span class="string">'db'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)]</span><br><span class="line">        # <span class="keyword">update</span> parameters</span><br><span class="line">        parameters[<span class="string">'W'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] = parameters[<span class="string">'W'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] - learning_rate * v[<span class="string">'dW'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)]</span><br><span class="line">        parameters[<span class="string">'b'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] = parameters[<span class="string">'b'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] - learning_rate * v[<span class="string">'db'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)]</span><br><span class="line">        ### END CODE HERE ###</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> parameters, v</span><br></pre></td></tr></table></figure></p><p></p><h3>3.RMSprop(均方根)</h3><br>RMSprop全称为 root mean square prop 均方根。他也可以用来加速梯度下降<p></p><p></p><h4>公式:</h4><br>$ S<em>{dw} = \beta S</em>{dw} + (1 - \beta)(dw)^2 $<br>$ S<em>{db} = \beta S</em>{db} + (1 - \beta)(db)^2 $<p></p><p></p><h4>参数更新</h4><br>$ W = W - \alpha \frac{dw}{\sqrt(S<em>{dw} + \epsilon)}$<br>$ b = b - \alpha \frac{db}{\sqrt(S</em>{db} + \epsilon )}$<br>$ \epsilon $防止分母为0.一般为很小的数, $10^{-8}$<p></p><p></p><h3>4.Adam</h3><br>Adam算法是训练神经网络最有效的优化算法之一,它结合了Momentum和RMSprop.<p></p><p></p><h4>公式</h4><br>$V<em>{dw} = \beta_1 V</em>{dw} + (1-\beta<em>1)dw $<br>$V</em>{dw}^{corrected} = \frac{V<em>{dw}}{(1-\beta_1^t)}$<br>$S</em>{dw} = \beta<em>2 S</em>{dw} + (1-\beta<em>2)(dw)^2$<br>$S</em>{dw}^{corrected} = \frac{S<em>{dw}}{1-\beta_2^t}$<br>$W = W - \alpha \frac{V</em>{dw}}{\sqrt( S_{dw} + \epsilon)}$<p></p><p>b同理,这里不再列出</p><p>这里我们可以看到,有了两个参数, $ \beta_1$ 和 $\beta_2$ ,通常情况下我们让$ \beta_1 = 0.9 $ $ \beta_2 = 0.999 $ $ \epsilon = 10 ^{-8}$</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"># GRADED FUNCTION: update_parameters_with_adam</span><br><span class="line"></span><br><span class="line">def update_parameters_with_adam(parameters, grads, v, s, t, learning_rate = <span class="number">0.01</span>,</span><br><span class="line">                                beta1 = <span class="number">0.9</span>, beta2 = <span class="number">0.999</span>,  epsilon = <span class="number">1</span><span class="keyword">e</span>-<span class="number">8</span>):</span><br><span class="line">    <span class="string">""</span><span class="comment">"</span></span><br><span class="line">    Update parameters using Adam</span><br><span class="line">    </span><br><span class="line">    Argument<span class="variable">s:</span></span><br><span class="line">    parameters -- <span class="keyword">python</span> dictionary containing your parameter<span class="variable">s:</span></span><br><span class="line">                    parameters[<span class="string">'W'</span> + str(<span class="keyword">l</span>)] = Wl</span><br><span class="line">                    parameters[<span class="string">'b'</span> + str(<span class="keyword">l</span>)] = <span class="keyword">bl</span></span><br><span class="line">    grads -- <span class="keyword">python</span> dictionary containing your gradients <span class="keyword">for</span> each parameter<span class="variable">s:</span></span><br><span class="line">                    grads[<span class="string">'dW'</span> + str(<span class="keyword">l</span>)] = dWl</span><br><span class="line">                    grads[<span class="string">'db'</span> + str(<span class="keyword">l</span>)] = dbl</span><br><span class="line">    v -- Adam variable, moving average of the <span class="keyword">first</span> gradient, <span class="keyword">python</span> dictionary</span><br><span class="line">    s -- Adam variable, moving average of the squared gradient, <span class="keyword">python</span> dictionary</span><br><span class="line">    learning_rate -- the learning rate, scalar.</span><br><span class="line">    beta1 -- Exponential decay hyperparameter <span class="keyword">for</span> the <span class="keyword">first</span> moment estimates </span><br><span class="line">    beta2 -- Exponential decay hyperparameter <span class="keyword">for</span> the second moment estimates </span><br><span class="line">    epsilon -- hyperparameter preventing division by zero in Adam updates</span><br><span class="line"></span><br><span class="line">    Return<span class="variable">s:</span></span><br><span class="line">    parameters -- <span class="keyword">python</span> dictionary containing your updated parameters </span><br><span class="line">    v -- Adam variable, moving average of the <span class="keyword">first</span> gradient, <span class="keyword">python</span> dictionary</span><br><span class="line">    s -- Adam variable, moving average of the squared gradient, <span class="keyword">python</span> dictionary</span><br><span class="line">    <span class="string">""</span><span class="comment">"</span></span><br><span class="line">    </span><br><span class="line">    L = <span class="built_in">len</span>(parameters) // <span class="number">2</span>                 # <span class="keyword">number</span> of layers in the neural networks</span><br><span class="line">    v_corrected = &#123;&#125;                         # Initializing <span class="keyword">first</span> moment estimate, <span class="keyword">python</span> dictionary</span><br><span class="line">    s_corrected = &#123;&#125;                         # Initializing second moment estimate, <span class="keyword">python</span> dictionary</span><br><span class="line">    </span><br><span class="line">    # Perform Adam <span class="keyword">update</span> <span class="keyword">on</span> <span class="keyword">all</span> parameters</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">l</span> in <span class="built_in">range</span>(L):</span><br><span class="line">        # Moving average of the gradients. Input<span class="variable">s:</span> <span class="string">"v, grads, beta1"</span>. Outpu<span class="variable">t:</span> <span class="string">"v"</span>.</span><br><span class="line">        ### START CODE HERE ### (approx. <span class="number">2</span> lines)</span><br><span class="line">        v[<span class="string">'dW'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] = beta1 * v[<span class="string">'dW'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] + (<span class="number">1</span>. - beta1) * grads[<span class="string">'dW'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)]</span><br><span class="line">        v[<span class="string">'db'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] = beta1 * v[<span class="string">'db'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] + (<span class="number">1</span>. - beta1) * grads[<span class="string">'db'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)]</span><br><span class="line">        ### END CODE HERE ###</span><br><span class="line"></span><br><span class="line">        # Compute bias-corrected <span class="keyword">first</span> moment estimate. Input<span class="variable">s:</span> <span class="string">"v, beta1, t"</span>. Outpu<span class="variable">t:</span> <span class="string">"v_corrected"</span>.</span><br><span class="line">        ### START CODE HERE ### (approx. <span class="number">2</span> lines)</span><br><span class="line">        v_corrected[<span class="string">'dW'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] = v[<span class="string">'dW'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] / (<span class="number">1</span>. - beta1**t)</span><br><span class="line">        v_corrected[<span class="string">'db'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] = v[<span class="string">'db'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] / (<span class="number">1</span>. - beta1**t)</span><br><span class="line">        ### END CODE HERE ###</span><br><span class="line"></span><br><span class="line">        # Moving average of the squared gradients. Input<span class="variable">s:</span> <span class="string">"s, grads, beta2"</span>. Outpu<span class="variable">t:</span> <span class="string">"s"</span>.</span><br><span class="line">        ### START CODE HERE ### (approx. <span class="number">2</span> lines)</span><br><span class="line">        s[<span class="string">'dW'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] = beta2 * s[<span class="string">'dW'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] + (<span class="number">1</span>. - beta2) * grads[<span class="string">'dW'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)]**<span class="number">2</span></span><br><span class="line">        s[<span class="string">'db'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] = beta2 * s[<span class="string">'db'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] + (<span class="number">1</span>. - beta2) * grads[<span class="string">'db'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)]**<span class="number">2</span></span><br><span class="line">        ### END CODE HERE ###</span><br><span class="line"></span><br><span class="line">        # Compute bias-corrected second raw moment estimate. Input<span class="variable">s:</span> <span class="string">"s, beta2, t"</span>. Outpu<span class="variable">t:</span> <span class="string">"s_corrected"</span>.</span><br><span class="line">        ### START CODE HERE ### (approx. <span class="number">2</span> lines)</span><br><span class="line">        s_corrected[<span class="string">'dW'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] = s[<span class="string">'dW'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] / (<span class="number">1</span>. - beta2**t)</span><br><span class="line">        s_corrected[<span class="string">'db'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] = s[<span class="string">'db'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] / (<span class="number">1</span>. - beta2**t)</span><br><span class="line">        ### END CODE HERE ###</span><br><span class="line"></span><br><span class="line">        # Update parameters. Input<span class="variable">s:</span> <span class="string">"parameters, learning_rate, v_corrected, s_corrected, epsilon"</span>. Outpu<span class="variable">t:</span> <span class="string">"parameters"</span>.</span><br><span class="line">        ### START CODE HERE ### (approx. <span class="number">2</span> lines)</span><br><span class="line">        parameters[<span class="string">'W'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] = parameters[<span class="string">'W'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] - learning_rate * v_corrected[<span class="string">'dW'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] / \</span><br><span class="line">        (np.<span class="built_in">sqrt</span>(s_corrected[<span class="string">'dW'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)]) + epsilon)</span><br><span class="line">        parameters[<span class="string">'b'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] = parameters[<span class="string">'b'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] - learning_rate * v_corrected[<span class="string">'db'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)] / \</span><br><span class="line">        (np.<span class="built_in">sqrt</span>(s_corrected[<span class="string">'db'</span> + str(<span class="keyword">l</span> + <span class="number">1</span>)]) + epsilon)</span><br><span class="line">        ### END CODE HERE ###</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parameters, v, s</span><br></pre></td></tr></table></figure></=>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/statusrank/deeplearning.ai-note&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;作业地址可查看github&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;一、初始化&lt;/h2&gt;
&lt;h3&gt;1.为什么神经网络的所有参数不能全部初始化为0&gt;?&lt;/h3&gt;
若w初始化为0 ,很可能导致模型失效,无法收敛。也就是说如果我们初始将所有的w初始化为0,那么进行前向传播时每一层得到的值都是一样,这样一来当我们使用反向传播时,传回的梯度也是一样的,这就导致了我们更新参数后w还是一样的,这就使得我们的NN不能各自学习到很好的特征了。[可以看这里](https://zhuanlan.zhihu.com/p/27190255)
    
    </summary>
    
    
      <category term="Deep Learning" scheme="https://statusrank.xyz/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>POJ3181 Dollar Dayz(完全背包+拆两个longlong模拟高精度)</title>
    <link href="https://statusrank.xyz/2018/08/13/2018-8-13/"/>
    <id>https://statusrank.xyz/2018/08/13/2018-8-13/</id>
    <published>2018-08-13T14:06:31.000Z</published>
    <updated>2018-08-13T14:11:04.344Z</updated>
    
    <content type="html"><![CDATA[<h3>[题意](https://vjudge.net/problem/POJ-3181)</h3><p>大体就是一个整数划分问题,用1~k的数去正好凑出n,问你有几种求法。<br><a id="more"></a></p><p></p><h3>思路:</h3><br>可以用完全背包来做,不过这里发现值很大,大约33位,所以可以拆成两个longlong,一个表示高位一个表示低位.<br>dp[j] += dp[j - i]<br>表示的就是在已经凑出的,dp[j-i]中添加i从而达到j状态。这样可以做到不重不漏.<p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> inf=<span class="number">1000000000000000000L</span>L;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span> + <span class="number">5</span>;</span><br><span class="line">ll gao[<span class="number">10</span> * maxn];</span><br><span class="line">ll di[<span class="number">10</span> * maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;k) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(gao,<span class="number">0</span>,<span class="keyword">sizeof</span> gao);</span><br><span class="line">        <span class="built_in">memset</span>(di,<span class="number">0</span>,<span class="keyword">sizeof</span> di);</span><br><span class="line">        di[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt;= n;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                gao[j] = gao[j] + gao[j - i] + (di[j] + di[j - i]) / inf;</span><br><span class="line">                di[j] = (di[j] + di[j - i]) % inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(gao[n] == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,di[n]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld%018lld\n"</span>,gao[n],di[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3&gt;[题意](https://vjudge.net/problem/POJ-3181)&lt;/h3&gt;

&lt;p&gt;大体就是一个整数划分问题,用1~k的数去正好凑出n,问你有几种求法。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ACM" scheme="https://statusrank.xyz/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>hdu6375&amp;&amp;2018百度之星 度度熊学队列(模拟双向列表)</title>
    <link href="https://statusrank.xyz/2018/08/12/2018-8-12-3/"/>
    <id>https://statusrank.xyz/2018/08/12/2018-8-12-3/</id>
    <published>2018-08-12T11:42:54.000Z</published>
    <updated>2018-08-12T11:49:07.542Z</updated>
    
    <content type="html"><![CDATA[<p></p><h3><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6375" target="_blank" rel="noopener">题意</a></h3><br><a id="more"></a><p></p><p></p><h3>思路</h3><br>大佬们都有很多思路,什么deque清内存,什么LCT的。我只会大力出奇迹,<font color="red">但是记得delete的时候因为没有将指向该结点的指针置位NULL,RE了一下午。。。</font><p></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void read(int &amp;x)&#123;</span><br><span class="line">char <span class="attr">ch</span> = getchar();<span class="attr">x</span> = <span class="number">0</span>;</span><br><span class="line">for (; ch &lt; '<span class="number">0</span>' || ch &gt; '<span class="number">9</span>'; <span class="attr">ch</span> = getchar());</span><br><span class="line">for (; ch &gt;='<span class="number">0</span>' &amp;&amp; ch &lt;= '<span class="number">9</span>'; <span class="attr">ch</span> = getchar()) <span class="attr">x</span> = x * <span class="number">10</span> + ch - '<span class="number">0</span>';</span><br><span class="line">&#125;</span><br><span class="line">const int <span class="attr">maxn</span> = <span class="number">150000</span> + <span class="number">1000</span>;</span><br><span class="line">int n,q;</span><br><span class="line"></span><br><span class="line">struct List&#123;</span><br><span class="line">    struct List *pre,*next;</span><br><span class="line">    int val;</span><br><span class="line">    struct List* head,*tail;</span><br><span class="line">    List()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">pre</span> = <span class="attr">next</span> = <span class="attr">head</span> = <span class="attr">tail</span> = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;s[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(~scanf(<span class="string">"%d %d"</span>,&amp;n,&amp;q))</span><br><span class="line">    &#123;</span><br><span class="line">        for(int <span class="attr">i</span> = <span class="number">1</span>;i &lt; maxn;++i) s[i] = List();</span><br><span class="line">        int u,v,w,val,op;</span><br><span class="line">        for(int <span class="attr">i</span> = <span class="number">1</span>;i &lt;= q;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            read(op),read(u);</span><br><span class="line">            //puts(<span class="string">"++++"</span>);</span><br><span class="line">            //cout &lt;&lt; op &lt;&lt; ' ' &lt;&lt; u &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span>(<span class="attr">op</span> == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                read(w),read(val);</span><br><span class="line">                List *<span class="attr">p</span> = new List();</span><br><span class="line">                p -&gt; <span class="attr">val</span> = val;</span><br><span class="line">                <span class="keyword">if</span>(s[u].<span class="attr">head</span> == NULL || s[u].<span class="attr">tail</span> == NULL)</span><br><span class="line">                    &#123;s[u].<span class="attr">head</span> = p,s[u].<span class="attr">tail</span> = p;&#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="attr">w</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        s[u].head -&gt; <span class="attr">pre</span> = p;</span><br><span class="line">                        p -&gt; <span class="attr">next</span> = s[u].head;</span><br><span class="line">                        s[u].<span class="attr">head</span> = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        s[u].tail -&gt; <span class="attr">next</span> = p;</span><br><span class="line">                        p -&gt; <span class="attr">pre</span> = s[u].tail;</span><br><span class="line">                        s[u].<span class="attr">tail</span> = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="attr">op</span> == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                read(w);</span><br><span class="line">                <span class="keyword">if</span>(s[u].<span class="attr">head</span> == NULL || s[u].<span class="attr">tail</span> == NULL) puts(<span class="string">"-1"</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="attr">w</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                        int <span class="attr">x</span> = s[u].head -&gt; val;</span><br><span class="line">                        <span class="keyword">if</span>(s[u].<span class="attr">head</span> == s[u].tail)</span><br><span class="line">                        &#123;</span><br><span class="line">                            s[u].<span class="attr">head</span> = s[u].<span class="attr">tail</span> = NULL;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            List *<span class="attr">q</span> = s[u].head;</span><br><span class="line">                            s[u].<span class="attr">head</span> = s[u].head -&gt; next;</span><br><span class="line">                            s[u].head -&gt; <span class="attr">pre</span> = NULL;</span><br><span class="line">                            delete q;</span><br><span class="line">                        &#125;</span><br><span class="line">                        printf(<span class="string">"%d\n"</span>,x);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        int <span class="attr">x</span> = s[u].tail -&gt; val;</span><br><span class="line">                        <span class="keyword">if</span>(s[u].<span class="attr">head</span> == s[u].tail)</span><br><span class="line">                            s[u].<span class="attr">tail</span> = s[u].<span class="attr">head</span> = NULL;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            List *<span class="attr">q</span> = s[u].tail;</span><br><span class="line">                            s[u].<span class="attr">tail</span> = s[u].tail -&gt; pre;</span><br><span class="line">                            s[u].tail -&gt; <span class="attr">next</span> = NULL;</span><br><span class="line">                            delete q;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        printf(<span class="string">"%d\n"</span>,x);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                read(v),read(w);</span><br><span class="line">                List *<span class="attr">vhead</span> = s[v].head,* <span class="attr">vtail</span> = s[v].tail;</span><br><span class="line">                <span class="keyword">if</span>(<span class="attr">vhead</span> == NULL || <span class="attr">vtail</span> == NULL) continue;</span><br><span class="line">                <span class="keyword">if</span>(<span class="attr">w</span> == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[u].<span class="attr">tail</span> == NULL || s[u].<span class="attr">head</span> == NULL )&#123;</span><br><span class="line">                        s[u].<span class="attr">head</span> = s[v].head,s[u].<span class="attr">tail</span> = s[v].tail;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        s[u].tail -&gt; <span class="attr">next</span> = s[v].head;</span><br><span class="line">                        s[v].head -&gt; <span class="attr">pre</span> = s[u].tail;</span><br><span class="line">                        s[u].<span class="attr">tail</span> = s[v].tail;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    while(vtail != NULL)</span><br><span class="line">                    &#123;</span><br><span class="line">                        swap(vtail -&gt; pre,vtail -&gt; next);</span><br><span class="line">                        //printf(<span class="string">"%d\n"</span>,vtail -&gt; val);</span><br><span class="line">                        <span class="attr">vtail</span> = vtail -&gt; next;</span><br><span class="line">                        //puts(<span class="string">"+++"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(s[u].<span class="attr">tail</span> == NULL || s[u].<span class="attr">head</span> == NULL )</span><br><span class="line">                    &#123;</span><br><span class="line">                        s[u].<span class="attr">tail</span> = s[v].head;</span><br><span class="line">                        s[u].<span class="attr">head</span> = s[v].tail;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        s[u].tail -&gt; <span class="attr">next</span> = s[v].tail;</span><br><span class="line">                        s[v].tail -&gt; <span class="attr">pre</span> = s[u].tail;</span><br><span class="line">                        s[u].<span class="attr">tail</span> = s[v].head;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                s[v].<span class="attr">head</span> = s[v].<span class="attr">tail</span> = NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6375&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题意&lt;/a&gt;&lt;/h3&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="ACM" scheme="https://statusrank.xyz/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>hdu 6376&amp;&amp; 2018百度之星 度度熊剪纸条(思维)</title>
    <link href="https://statusrank.xyz/2018/08/12/2018-8-12-2/"/>
    <id>https://statusrank.xyz/2018/08/12/2018-8-12-2/</id>
    <published>2018-08-12T11:35:22.000Z</published>
    <updated>2018-08-12T11:42:48.325Z</updated>
    
    <content type="html"><![CDATA[<h3>[题意](http://acm.hdu.edu.cn/showproblem.php?pid=6376)</h3><a id="more"></a><h3>思路</h3><p>首先想到要想1最多,我们肯定会优先切最多的连续的1,而一段1必须切两次,左一次右一次,记为[1,1].然而存在一些特殊情况,如果开头有连续的1,那么我们只需要切[0,1].如果末尾有连续的1,我们只需要切[1,0]次。那么我们就可以预处理出所有的连续1的段,按他们的个数排序然后贪心的来找就好了。<br>但是存在几个情况需要考虑下,对于末尾的1,我们不要求它全是1,也就是说他的后面可以有0,也就是说我们可以把[x,1]的1修改一次,即让他构成末尾串，(注意这个修改要考虑开头串和中间串)</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">num</span>;</span><br><span class="line">    <span class="built_in">int</span> x,y;</span><br><span class="line">&#125;s[maxn];</span><br><span class="line"><span class="built_in">int</span> cmp(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">num</span> != b.<span class="built_in">num</span>)</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">num</span> &gt; b.<span class="built_in">num</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a.x + a.y &lt; b.x + b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> k,n;</span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(scanf(<span class="string">"%d %d"</span>,&amp;n,&amp;k) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        string str;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        <span class="built_in">int</span> cnt = <span class="number">0</span>,<span class="built_in">num</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> beg = <span class="number">-1</span>,sta_num = <span class="number">0</span>,en_num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; str.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">'1'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(beg == <span class="number">-1</span>)</span><br><span class="line">                    beg = i;</span><br><span class="line">                <span class="built_in">num</span>++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(str[i] == <span class="string">'0'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">num</span> == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(beg == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            s[cnt].<span class="built_in">num</span> = <span class="built_in">num</span>;</span><br><span class="line">                            sta_num = <span class="built_in">num</span>,<span class="built_in">num</span> = <span class="number">0</span>;</span><br><span class="line">                            beg = <span class="number">-1</span>;</span><br><span class="line">                            s[cnt].x = <span class="number">0</span>,s[cnt].y = <span class="number">1</span>;</span><br><span class="line">                            cnt++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            s[cnt].<span class="built_in">num</span> = <span class="built_in">num</span>,<span class="built_in">num</span> = <span class="number">0</span>;</span><br><span class="line">                            beg = <span class="number">-1</span>;</span><br><span class="line">                            s[cnt].x = s[cnt].y = <span class="number">1</span>;</span><br><span class="line">                            cnt++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">// cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; beg &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(beg != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(beg == <span class="number">0</span>)</span><br><span class="line">                s[cnt].x = <span class="number">0</span>,s[cnt].y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s[cnt].x = <span class="number">1</span>,s[cnt].y = <span class="number">0</span>;</span><br><span class="line">            s[cnt++].<span class="built_in">num</span> = <span class="built_in">num</span>,en_num = <span class="built_in">num</span>,<span class="built_in">num</span> = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line">        sort(s,s + cnt,cmp);</span><br><span class="line">        <span class="built_in">int</span> sum = <span class="number">0</span>,o = k;</span><br><span class="line">        <span class="built_in">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[cur].y == <span class="number">0</span> &amp;&amp; cur &lt; cnt) cur++;</span><br><span class="line">        s[cur].y = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; cur &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//for(int i = 0;i &lt; cnt;++i)</span></span><br><span class="line">           <span class="comment">//cout &lt;&lt; s[i].num &lt;&lt; ' ' &lt;&lt; s[i].x &lt;&lt; ' ' &lt;&lt; s[i].y &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; cnt;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &gt;= s[i].x + s[i].y)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += s[i].<span class="built_in">num</span>;</span><br><span class="line">                k -= (s[i].x + s[i].y);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">//printf("%d\n",sum);</span></span><br><span class="line">        s[cur].y = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> ma = sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; cnt;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i].x == <span class="number">0</span> &amp;&amp; s[i].y == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s[i].y = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        k = o;</span><br><span class="line">         <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; cnt;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &gt;= s[i].x + s[i].y)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += s[i].<span class="built_in">num</span>;</span><br><span class="line">                k -= (s[i].x + s[i].y);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//puts("----");</span></span><br><span class="line">         <span class="comment">// for(int i = 0;i &lt; cnt;++i)</span></span><br><span class="line">           <span class="comment">//cout &lt;&lt; s[i].num &lt;&lt; ' ' &lt;&lt; s[i].x &lt;&lt; ' ' &lt;&lt; s[i].y &lt;&lt; endl;</span></span><br><span class="line">         cout &lt;&lt; max(sum,ma) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">12 1</span></span><br><span class="line"><span class="comment">110111010111</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3&gt;[题意](http://acm.hdu.edu.cn/showproblem.php?pid=6376)&lt;/h3&gt;
    
    </summary>
    
    
      <category term="ACM" scheme="https://statusrank.xyz/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>hdu 6383&amp;&amp;2018百度之星 p1m2 二分</title>
    <link href="https://statusrank.xyz/2018/08/12/2018-8-12-1/"/>
    <id>https://statusrank.xyz/2018/08/12/2018-8-12-1/</id>
    <published>2018-08-12T11:07:24.000Z</published>
    <updated>2018-08-12T11:34:03.444Z</updated>
    
    <content type="html"><![CDATA[<h3>[题意](http://acm.hdu.edu.cn/showproblem.php?pid=6383)</h3><a id="more"></a><h3>思路</h3><p>很水的一题啊…菜。<br>最小问题最大化，立马想到二分,卡在了怎么验证，稍微一想就明白了,-2 + 1,每次都是会使整个数列和-1,可以证明给定一个数组（非零）,一定存在稳定数组。且答案具有单调性,当最小值为x的满足,则x-1也满足。<br>对于验证:<br>二分最小值x,对于$a_i &gt; x$ 则需要进行 $ \lfloor \frac{a_i - x}{2} \rfloor$ 次,<br>$a_i &lt;= x$ 则需要加 $ x-a_i$次。<br>如果减的次数大于等于加的次数则一定满足条件</p><p>具体为什么满足减&gt;加即可,这个也是可以被严格的证明的,但是我不太会,可以自己去网上了解一下,我只是大概一想是这样的,而且造不出反例<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll jian = <span class="number">0</span>,jia = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt;= x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cha = a[i] - x;</span><br><span class="line">            <span class="keyword">if</span>(cha % <span class="number">2</span> == <span class="number">0</span>) jian += cha / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> jian += (cha - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cha = x - a[i];</span><br><span class="line">            jia += cha;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jian &gt;= jia;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>,mid;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),r = max(r,a[i]);</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; mid &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span>(check(mid))</span><br><span class="line">            &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3&gt;[题意](http://acm.hdu.edu.cn/showproblem.php?pid=6383)&lt;/h3&gt;
    
    </summary>
    
    
      <category term="ACM" scheme="https://statusrank.xyz/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>卷积神经网络原理与实例</title>
    <link href="https://statusrank.xyz/2018/08/06/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>https://statusrank.xyz/2018/08/06/卷积神经网络/</id>
    <published>2018-08-06T13:48:24.000Z</published>
    <updated>2018-08-07T08:33:07.716Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://my.oschina.net/u/876354/blog/1620906" target="_blank" rel="noopener">本文学习自雪饼大佬,感谢!</a><br><a href="https://www.coursera.org/specializations/deep-learning" target="_blank" rel="noopener">其余大部分内容学习自吴恩达深度学习课程</a><br><a id="more"></a></p><h1>1.什么是神经网络？</h1><p>这里的神经网络也指人工神经网络（Artificial Neural Networks，简称ANNs），是一种模仿生物神经网络行为特征的算法数学模型，由神经元、节点与节点之间的连接（突触）所构成，如下图：<br><img src="/2018/08/06/卷积神经网络/1.png"></p><p>每个神经网络单元抽象出来的数学模型如下，也叫感知器，它接收多个输入（x1，x2，x3…），产生一个输出，这就好比是神经末梢感受各种外部环境的变化（外部刺激），然后产    生电信号，以便于转导到神经细胞（又叫神经元）。<br><img src="/2018/08/06/卷积神经网络/2.png"><br>对应公式如下:<br>$ h<em>{W,b}(x) = f(W^Tx) = f(\sum</em>{i = 1}^3 W_ix_i + b)$<br>单个的感知器就构成了一个简单的模型，但在现实世界中，实际的决策模型则要复杂得多，往往是由多个感知器组成的多层网络，如下图所示，这也是经典的神经网络模型，由输入层、隐含层、输出层构成。<br><img src="/2018/08/06/卷积神经网络/3.png"><br>人工神经网络可以映射任意复杂的非线性关系，具有很强的鲁棒性、记忆能力、自学习等能力，在分类、预测、模式识别等方面有着广泛的应用。</p><p></p><h1>2.什么是卷积神经网络?</h1><br>  受Hubel和Wiesel对猫视觉皮层电生理研究启发，有人提出卷积神经网络（CNN），Yann Lecun 最早将CNN用于手写数字识别并一直保持了其在该问题的霸主地位。近年来卷积神经网络在多个方向持续发力，在语音识别、人脸识别、通用物体识别、运动分析、自然语言处理甚至脑电波分析方面均有突破。<p></p><font color="red">卷积神经网络最主要的三层:卷积层、池化层、全连接神经网络</font>卷积神经网络的基本结构图:    <img src="/2018/08/06/卷积神经网络/18.png">卷积神经网络与普通的神经网络的区别在于,卷积神经网络包含了一个由卷积层和池化层构成的特征抽取器。在卷积神经网络的卷积层中通常包含若干个特征平面,每个特征平面由一些矩形排列的的神经元组成，同一特征平面的神经元共享权值，这里共享的权值就是卷积核。卷积核一般以随机小数矩阵的形式初始化,在网络的训练过程中卷积核将学习到合理的权值。通常采用卷积核的大小为3*3,也有5*5,7*7，但大多数为奇数.卷积核带来的好处是减少了网络各层之间的连接,参数减少，又降低了过拟合的风险。池化层也叫子采样,通常有max-pooling 和 average-pooling ,但通常我们使用max-pooling.卷积和池化大大简化了模型复杂度,减少了参数。<h2>1)什么是卷积？</h2>当给定了一张新图时,CNN并不能准确的知道这些特征到底要匹配原图的哪些部分,所以它会在原图中把每一个可能的位置都进行尝试,相当于把这个特征(feature)变成了一个过滤器。这个用来匹配的过程就称为卷积操作。(特别注意,在卷积神经网络中进行的卷积操作其实本质上并不是严格的卷积,许多数学家把他们叫做互相关,但是在许多DL文献中我们把他看成卷积,真正的卷积是需要进行水平垂直的镜像)卷积操作如图:    <img src="/2018/08/06/卷积神经网络/4.gif">说白了要计算一个feature和其在原图上对应的某一小块的结果,只需要将两个小块对应位置的像素值进行乘法运算,然后将整个小块内的乘法运算的结果累加起来。(也可能还会有其余的操作,比如除以像素点总个数啊等等)。如下是一个6x6的灰度图像，构造一个3x3的矩阵，在卷积神经网络中通常称之为filter，对这个6x6的图像进行卷积运算，以左上角的-5计算为例 其它的以此类推，让过滤器在图像上逐步滑动，对整个图像进行卷积计算得到一幅4x4的图像。<img src="/2018/08/06/卷积神经网络/5.png"><h3>卷积步长</h3>卷积步长是指过滤器在图像上滑动的距离，前两部分步长都默认为1，如果卷积步长为2，卷积运算过程为： <img src="/2018/08/06/卷积神经网络/10.png"><img src="/2018/08/06/卷积神经网络/11.png"><img src="/2018/08/06/卷积神经网络/12.png"><h2>2)卷积是如何提取特征的？</h2><h3>边界检测实例</h3>假如你有一张如下的图像，你想让计算机搞清楚图像上有什么物体，你可以做的事情是检测图像的垂直边缘和水平边缘。 <img src="/2018/08/06/卷积神经网络/6.png">为什么这种卷积计算可以得到图像的边缘，下图0表示图像暗色区域，10为图像比较亮的区域，同样用一个3x3过滤器，对图像进行卷积，得到的图像中间亮，两边暗，亮色区域就对应图像边缘。 <img src="/2018/08/06/卷积神经网络/7.png"><font color="red">注意:这里由于我们图片大小仅仅是6x6所以可以发现中间的亮色区域是很宽的,当我们的图很大的时候是不会发生这种情况的。</font>通过以下的水平过滤器和垂直过滤器，可以实现图像水平和垂直边缘检测。 <img src="/2018/08/06/卷积神经网络/8.png"><h2>padding</h2>在上部分中，通过一个3x3的过滤器来对6x6的图像进行卷积，得到了一幅4x4的图像，假设输入图像大小nxn，过滤器filter大小为fxf，步长为s,那么输出图像大小为 ($ \lfloor\frac{n - f}{s}\rfloor + 1 $) x ($\lfloor\frac{n - f}{s}\rfloor + 1  $)<font color="blue">这样做卷积运算的缺点是卷积图像的大小会不断缩小,另外图像的左上角元素只被一个输出所使用,而下图中红色阴影部分的像素却被多个输出使用了,所以图像的边缘像素在输出中采用较少,这也就意味着你会丢掉许多图像边缘信息,为了引入这两个问题我们引入padding操作,也就是在图像做卷积操作之前,沿着图像边缘用0进行填充对于3x3的过滤器，我们填充宽度为1时，就可以保证输出图像和输入图像一样大。如下图</font><img src="/2018/08/06/卷积神经网络/9.png">padding的两种模式:    valid: no padding    same padding: 输入图像和输出图像大小一样大.这里我们用p来表示我们填充的宽度,则使用padding后我们输出图像的大小关系为:    ($ \lfloor\frac{n + 2p - f}{s} \rfloor + 1$) x ($ \lfloor\frac{n + 2p - f}{s} \rfloor + 1$)<h2>3)彩色图像的卷积</h2>以上我们所说的卷积都是灰度值图像的,也就是一维的。我们知道彩色图像在计算机中都是按照RGB来存的,所以如果我们想要在彩色图像上进行卷一那么过滤器的大小就不能使$3x3$ 而应该是$3x3x3$（RGB三通道,通道数）卷积生成图像中每个像素值为 $3*3*3$ 过滤器对应位置和图像对应位置相乘累加,过滤器依次再RGB图像上滑动,最终生成图像大小为$4x4$<img src="/2018/08/06/卷积神经网络/13.png">另外一个问题是，如果我们在不仅仅在图像总检测一种类型的特征，而是要同时检测垂直边缘、水平边缘、45度边缘等等，也就是多个过滤器的问题。如果有两个过滤器，最终生成图像为$4x4x2$的立方体，这里的2来源于我们采用了两个过滤器。如果有10个过滤器那么输出图像就是$4x4x10$的立方体。<img src="/2018/08/06/卷积神经网络/14.png"><h2>4)池化层Pooling</h2>为了有效减少计算,CNN使用另一个有效的工具被称为"池化"。池化就是将输入图像进行缩小,减少像素信息,保留重要的信息。<h3>Max-pooling最大值池化</h3>最大池化思想很简单，以下图为例，把4x4的图像分割成4个不同的区域，然后输出每个区域的最大值，这就是最大池化所做的事情。其实这里我们选择了2*2的过滤器，步长为2。在一幅真正的图像中提取最大值可能意味着提取了某些特定特征，比如垂直边缘、一只眼睛等等。 <img src="/2018/08/06/卷积神经网络/15.png">以下是一个过滤器大小为3*3，步长为1的池化过程，具体计算和上面相同，最大池化中输出图像的大小计算方式和卷积网络中计算方法一致，如果有多个通道需要做池化操作，那么就分通道计算池化操作。 <img src="/2018/08/06/卷积神经网络/16.png">最大池化（max-pooling）因为对于每一个filter,它其实就是一个特征提取器,专门用来提取某种特征,所以对于特定区域内,最后的结果越大表示匹配的越好。也就是说，它不会具体关注窗口内到底是哪一个地方匹配了，而只关注是不是有某个地方匹配上了。<h3>average polling</h3>平均池化和最大池化唯一的不同是，它计算的是区域内的平均值而最大池化计算的是最大值。在日常应用使用最多的还是最大池化。 <img src="/2018/08/06/卷积神经网络/17.png"><font color="red">池化的超参数:filter的大小,步长,池化的类型.</font><font color="red">虽然这里池化层的参数我们也叫超参数,但是一般情况下她其实就是固定的,是不需要CNN进行学习的,一般我们采用最大值池化,过滤器大小为2,步长为2.</font><h2>5)激活函数Relu</h2>上面介绍卷积神经网络CNN结构时用的那个图大家可以看到,卷积层我们一般用CONV来表示,RELU就是我们激活函数的一种,POOL就是我们的池化层，FC就是全连接神经网络。这里需要注意的是池化层的多少没有很明确的规定,需要我们自己进行交叉验证或者调参来决定。而每一个卷积层后都是要跟着激活函数的RELU的。常用的激活函数有sigmod,tanh,relu等，其中sigmod,tanh主要用于全连接fc层,而Relu主要用于卷积层。回顾一下我们前面讲的神经网络中,单个神经元在接受到和输入计算wx+b后,求和经过一个函数f,输出得到h(x).这里的f就是我们的激活函数。<font color="red">激活函数的主要作用是加入非线性因素,把卷积层输出结果做非线性映射。这也是我们引入神经网络的目的,如果不加入激活函数那么对wx+b的计算还是线性的</font><img src="/2018/08/06/卷积神经网络/19.png">在卷积神经网络中激活函数一般使用Relu(The Rectified Linear Unit，修正线性单元),他的主要特点是收敛速度快,求梯度简单,公式简单max(0,s)，即对于输入的负值输出全为0,正值输出其本身。<h2>6)全连接层(Fully connected layers)</h2>全连接层在整个神经网络中期到分类器的作用,即通过卷积、激活函数、池化等深度网络后,再经过全连接层对结果进行分类。这里我们还是要将得到的图像拉伸成一个一维向量,就像前面我们使用fc对图像(像素较小的)进行分类一样，由于神经网络是属于监督学习，在模型训练时，根据训练样本对模型进行训练，从而得到全连接层的权重(在每个分类的得分)<img src="/2018/08/06/卷积神经网络/20.png"><h1>3.为什么我们需要CNN?</h1>全连接神经网络参数过于庞大,例如:假设我们有一张1000x1000的图像,隐藏层我们有100万个神经元,由于每个隐藏层的神经元都要与图像的每个像素点连接,所以这里我们就有$1000000 * 1000000 = 10^12$ 个连接,也就需要$10^12$个参数,那么这个参数是过于庞大的。卷积神经网络有两个神器可以用来降低参数,一个叫局部感受野,一叫交权值共享。<h2>局部感受野</h2>我们一般认为人对外界的认知是从局部到全局的,而图像的空间联系也是局部的像素联系较为紧密,而距离较远的像素相关性较弱。因而,每个神经元其实没必要对全局图像进行感知,只需要对局部进行感知,然后在更高层将局部的信息综合起来就得到了全局的信息。这种思想也是受启发与生物学里面的系统结构，视觉皮层的神经元就是局部接受信息的（即这些神经元只响应某些特定区域的刺激）如下图所示：左图为全连接，右图为局部连接。<img src="/2018/08/06/卷积神经网络/21.jpg">这个图就是描述上面的例子,这里如果我们采用局部感受野的话可以知道,每个像素不需要和所有神经元都连接,假设局部感受野的大小为10x10,隐藏层的神经元都只和每个感受野连接,此时我们的参数个数为 $1000000 * 10 * 10 = 10^8.$ 这样的话我们的参数个数就变为了原来的万分之一,但是还是很多啊,所以就出现了权值共享<h2>权值共享</h2>上面当中每个隐藏层神经元都连接不同的局部感受野,那么如果每个局部感受野的参数都相同,那么我的参数就变为 10*10 = 100.我们可以把这100参数对应的卷积操作看成是提取特征的一种方式,与位置无关。这是CNN的亮点之一,但是有一个问题就是说如果所有的参数都相同,也就是说我们只是提取了特定的某种特征,那么如果我们想要提取多种特征怎么办,这时候我们就需要多增加几个滤波器,每个filter对应提取不同的特征(参数不一样)。<h1>4.一个简单实例</h1>假设给定一张图（可能是字母X或者字母O），通过CNN即可识别出是X还是O，如下图所示，那怎么做到的呢<img src="/2018/08/06/卷积神经网络/21.png">如果采用经典的神经网络模型，则需要读取整幅图像作为神经网络模型的输入（即全连接的方式），当图像的尺寸越大时，其连接的参数将变得很多，从而导致计算量非常大。<h2>(1)提取特征</h2>如果字母X、字母O是固定不变的，那么最简单的方式就是图像之间的像素一一比对就行，但在现实生活中，字体都有着各个形态上的变化（例如手写文字识别），例如平移、缩放、旋转、微变形等等，如下图所示：<img src="/2018/08/06/卷积神经网络/22.png">我们的目标是对于各种形态变化的X和O，都能通过CNN准确地识别出来，这就涉及到应该如何有效地提取特征，作为识别的关键因子。<font color="red"></font>对于CNN来说，它是一小块一小块地来进行比对，在两幅图像中大致相同的位置找到一些粗糙的特征（小块图像）进行匹配，相比起传统的整幅图逐一比对的方式，CNN的这种小块匹配方式能够更好的比较两幅图像之间的相似性。如下图：<img src="/2018/08/06/卷积神经网络/23.png">以字母X为例，可以提取出三个重要特征（两个交叉线、一个对角线），如下图所示：<img src="/2018/08/06/卷积神经网络/24.png">假如以像素值"1"代表白色，像素值"-1"代表黑色，则字母X的三个重要特征如下：<img src="/2018/08/06/卷积神经网络/27.png"><h2>(2)计算卷积</h2>在本案例中，要计算一个feature（特征）和其在原图上对应的某一小块的结果，只需将两个小块内对应位置的像素值进行乘法运算，然后将整个小块内乘法运算的结果累加起来，最后再除以小块内像素点总个数即可（注：也可不除以总个数的）。如果两个像素点都是白色（值均为1），那么$1x1 = 1$，如果均为黑色，那么$(-1)*(-1) = 1$，也就是说，每一对能够匹配上的像素，其相乘结果为1。类似地，任何不匹配的像素相乘结果为-1。具体过程如下（第一个、第二个……、最后一个像素的匹配结果）：<img src="/2018/08/06/卷积神经网络/28.png"><img src="/2018/08/06/卷积神经网络/29.png"><img src="/2018/08/06/卷积神经网络/30.png">根据卷积的计算方式，第一块特征匹配后的卷积计算如下，结果为1<img src="/2018/08/06/卷积神经网络/31.png">对于其它位置的匹配，也是类似（例如中间部分的匹配）<img src="/2018/08/06/卷积神经网络/32.png">计算之后的卷积如下：    <img src="/2018/08/06/卷积神经网络/33.png">以此类推，对三个特征图像不断地重复着上述过程，通过每一个feature（特征）的卷积操作，会得到一个新的二维数组，称之为feature map。其中的值，越接近1表示对应位置和feature的匹配越完整，越是接近-1，表示对应位置和feature的反面匹配越完整，而值接近0的表示对应位置没有任何匹配或者说没有什么关联。如下图所示：<img src="/2018/08/06/卷积神经网络/34.png">可以看出，当图像尺寸增大时，其内部的加法、乘法和除法操作的次数会增加得很快，每一个filter的大小和filter的数目呈线性增长。由于有这么多因素的影响，很容易使得计算量变得相当庞大。<h2>(3)池化</h2>采用max-pooling如下图：<img src="/2018/08/06/卷积神经网络/35.png">池化区域往左，第二小块取大值max(0.11,0.33,-0.11,0.33)，作为池化后的结果，如下图：<img src="/2018/08/06/卷积神经网络/36.png">其它区域也是类似，取区域内的最大值作为池化后的结果，最后经过池化后，结果如下：<img src="/2018/08/06/卷积神经网络/37.png">对所有的feature map执行同样的操作，结果如下：<img src="/2018/08/06/卷积神经网络/38.png"><font color="blue">最大池化（max-pooling）保留了每一小块内的最大值，也就是相当于保留了这一块最佳的匹配结果（因为值越接近1表示匹配越好）。也就是说，它不会具体关注窗口内到底是哪一个地方匹配了，而只关注是不是有某个地方匹配上了。通过加入池化层，图像缩小了，能很大程度上减少计算量，降低机器负载。</font><h2>(4)Relu激活函数</h2>第一个值，取max(0,0.77)，结果为0.77，如下图<img src="/2018/08/06/卷积神经网络/40.png">以此类推，经过ReLU激活函数后，结果如下：<img src="/2018/08/06/卷积神经网络/41.png">对所有的feature map执行ReLU激活函数操作，结果如下：<img src="/2018/08/06/卷积神经网络/42.png"><h2>(5)深度神经网络</h2>通过将上面所提到的卷积、激活函数、池化组合在一起，就变成下图：<img src="/2018/08/06/卷积神经网络/43.png">通过加大网络的深度，增加更多的层，就得到了深度神经网络，如下图：<img src="/2018/08/06/卷积神经网络/44.png"><h2>(6)全连接层</h2>全连接层在整个卷积神经网络中起到“分类器”的作用，即通过卷积、激活函数、池化等深度网络后，再经过全连接层对结果进行识别分类。首先将经过卷积、激活函数、池化的深度网络后的结果串起来，如下图所示：<img src="/2018/08/06/卷积神经网络/45.png">由于神经网络是属于监督学习，在模型训练时，根据训练样本对模型进行训练，从而得到全连接层的权重（如预测字母X的所有连接的权重）<img src="/2018/08/06/卷积神经网络/46.png">在利用该模型进行结果识别时，根据刚才提到的模型训练得出来的权重，以及经过前面的卷积、激活函数、池化等深度网络计算出来的结果，进行加权求和，得到各个结果的预测值，然后取值最大的作为识别的结果（如下图，最后计算出来字母X的识别值为0.92，字母O的识别值为0.51，则结果判定为X）<img src="/2018/08/06/卷积神经网络/47.png"><font color="red">上述这个过程定义的操作为”全连接层“(Fully connected layers)，全连接层也可以有多个，如下图：</font><img src="/2018/08/06/卷积神经网络/48.png"><h2>(7)卷积神经网络</h2><p>将以上所有结果串起来后，就形成了一个“卷积神经网络”（CNN）结构，如下图所示:<br><img src="/2018/08/06/卷积神经网络/49.png"></p><p>再回顾总结一下，卷积神经网络主要由两部分组成，一部分是特征提取（卷积、激活函数、池化），另一部分是分类识别（全连接层），下图便是著名的手写文字识别卷积神经网络结构图：<br><img src="/2018/08/06/卷积神经网络/50.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://my.oschina.net/u/876354/blog/1620906&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本文学习自雪饼大佬,感谢!&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.coursera.org/specializations/deep-learning&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;其余大部分内容学习自吴恩达深度学习课程&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Deep Learning" scheme="https://statusrank.xyz/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>2018百度之星-调查问卷(状压dp)</title>
    <link href="https://statusrank.xyz/2018/08/05/2018-8-5/"/>
    <id>https://statusrank.xyz/2018/08/05/2018-8-5/</id>
    <published>2018-08-05T12:56:43.000Z</published>
    <updated>2018-08-05T13:07:40.327Z</updated>
    
    <content type="html"><![CDATA[<p></p><h3>题意</h3><br>Problem Description<br>度度熊为了完成毕业论文，需要收集一些数据来支撑他的论据，于是设计了一份包含 m 个问题的调查问卷，每个问题只有 ‘A’ 和 ‘B’ 两种选项。 将问卷散发出去之后，度度熊收到了 n 份互不相同的问卷，在整理结果的时候，他发现可以只保留其中的一部分问题，使得这 n 份问卷仍然是互不相同的。这里认为两张问卷是不同的，当且仅当存在至少一个被保留的问题在这两份问卷中的回答不同。 现在度度熊想知道，存在多少个问题集合，使得这 n 份问卷在只保留这个集合的问题之后至少有 k 对问卷是不同的。<br><a id="more"></a><br>Input<br>第一行包含一个整数 T，表示有 T 组测试数据。 接下来依次描述 T 组测试数据。对于每组测试数据： 第一行包含三个整数 n，m 和 k，含义同题目描述。 接下来 n 行，每行包含一个长度为 m 的只包含 ‘A’ 和 ‘B’ 的字符串，表示这份问卷对每个问题的回答。 保证 1≤T≤100，1≤n≤103，1≤m≤10，1≤k≤106，给定的 n 份问卷互不相同。<p></p><p>Output<br>对于每组测试数据，输出一行信息 “Case #x: y”（不含引号），其中 x 表示这是第 x 组测试数据，y 表示满足条件的问题集合的个数，行末不要有多余空格。</p><p>Sample Input<br>Copy<br>2<br>2 2 1<br>AA<br>BB<br>2 2 2<br>AA<br>BBSample Output<br>Copy<br>Case #1: 3<br>Case #2: 0</p><p></p><h3>思路</h3><br>观察到n比较大,m很小，而且是一个集合问题。所以我们可以想到这里可以利用二进制枚举集合的状态,$2^10 = 1024$。那么剩下的问题就是怎么去验证。dp[i][j]表示前i个物品中当集合状态为j时不同的问卷数目.<br>注意观察,只要有一位不同就算不同,所以我们开一个数组,num[sta]前面1~i-1个物品中,当集合状态为j时,和i问卷答案相同(i的答案此时为sta)的问卷数,那么剩下的都不同,即有:<br>dp[i][j] = dp[i - 1][j] + i - num[sta].<p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">1025</span>],num[<span class="number">1025</span>];</span><br><span class="line"><span class="keyword">char</span> str[maxn][<span class="number">12</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _,ca = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str[i]);</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sta = <span class="number">0</span>;sta &lt; (<span class="number">1</span> &lt;&lt; m);++sta)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span> num);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;++j)</span><br><span class="line">                    <span class="keyword">if</span>(sta &amp; (<span class="number">1</span> &lt;&lt; j) &amp;&amp; str[i][j] == <span class="string">'A'</span>)</span><br><span class="line">                        tmp |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                num[tmp]++;</span><br><span class="line">                dp[i][sta] = dp[i - <span class="number">1</span>][sta] + i - num[tmp];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sta = <span class="number">0</span>;sta &lt; (<span class="number">1</span> &lt;&lt; m);++sta)</span><br><span class="line">            <span class="keyword">if</span>(dp[n][sta] &gt;= k) ans++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %I64d\n"</span>,ca++,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;h3&gt;题意&lt;/h3&gt;&lt;br&gt;Problem Description&lt;br&gt;度度熊为了完成毕业论文，需要收集一些数据来支撑他的论据，于是设计了一份包含 m 个问题的调查问卷，每个问题只有 ‘A’ 和 ‘B’ 两种选项。 将问卷散发出去之后，度度熊收到了 n 份互不相同的问卷，在整理结果的时候，他发现可以只保留其中的一部分问题，使得这 n 份问卷仍然是互不相同的。这里认为两张问卷是不同的，当且仅当存在至少一个被保留的问题在这两份问卷中的回答不同。 现在度度熊想知道，存在多少个问题集合，使得这 n 份问卷在只保留这个集合的问题之后至少有 k 对问卷是不同的。&lt;br&gt;
    
    </summary>
    
    
      <category term="Dp" scheme="https://statusrank.xyz/tags/Dp/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口的最大值(单调队列)</title>
    <link href="https://statusrank.xyz/2018/08/03/2018-8-3-1/"/>
    <id>https://statusrank.xyz/2018/08/03/2018-8-3-1/</id>
    <published>2018-08-03T06:00:32.000Z</published>
    <updated>2018-08-03T06:08:08.726Z</updated>
    
    <content type="html"><![CDATA[<h3>题意</h3><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。<br><a id="more"></a></p><h3>思路:</h3><p>典型的单调队列解决滑动窗口问题。</p><p>这里因为我们需要获得的是长度为size的最大值,所以我们可以维护一个单调的递减队列,这样队首即为最大值。但是这里我们需要用到双端队列(deque)因为我们还需要从队尾取,队列中存储的全部是下标(组这样好判断区间长度)很显然所有的都需要入队的,不过当入队时需要判断当前的数和队尾的大小,如果当前大那么队尾不可能成为答案的(这也是为了保证递减特性)。同时还需要从队首判断区间差是否超过了size,超过也需要pop出来。</p><font color="red">这里需要注意使用的unsigned int，unsigned 出现负数是直接用补码表示出来的 </font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> v=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> b=<span class="number">5</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v-b&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//输出4294967292，因为没有负数</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num.size() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans;ans.clear();</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;q; <span class="comment">//双端队列中存放下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(q.size() &amp;&amp; num[q.back()] &lt;= num[i]) q.pop_back();</span><br><span class="line">            <span class="keyword">while</span>(q.size() &amp;&amp; i - q.front() + <span class="number">1</span> &gt; size) q.pop_front();</span><br><span class="line">            q.push_back(i);</span><br><span class="line">            <span class="keyword">if</span>(size &amp;&amp; i + <span class="number">1</span> &gt;= size) ans.push_back(num[q.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3&gt;题意&lt;/h3&gt;

&lt;p&gt;给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://statusrank.xyz/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>数据流中的中位数</title>
    <link href="https://statusrank.xyz/2018/08/02/2018-8-2-0/"/>
    <id>https://statusrank.xyz/2018/08/02/2018-8-2-0/</id>
    <published>2018-08-02T08:57:43.000Z</published>
    <updated>2018-08-02T09:03:14.411Z</updated>
    
    <content type="html"><![CDATA[<h3>题意</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。<br><a id="more"></a></p><p></p><h3>思路</h3><br>这个题目我们可以维护两个堆,一个大顶堆一个小顶堆,小顶堆的最小的数大于等于大顶堆中的最大的数,同时保证二者之间元素的个数最多大顶堆比小顶堆多1,那么我们便可以知道中位数一定位于两个堆顶元素中.(要么是大顶堆中最大的,要么是二者的均值)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!p.empty()) p.pop();</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.empty() || num &lt;= p.top()) p.push(num);</span><br><span class="line">        <span class="keyword">else</span> q.push(num);</span><br><span class="line">        <span class="keyword">if</span>(p.size() - q.size() == <span class="number">2</span>) q.push(p.top()),p.pop();</span><br><span class="line">        <span class="keyword">if</span>(p.size() &lt; q.size()) p.push(q.top()),q.pop();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = p.size() + q.size();</span><br><span class="line">        <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>) <span class="keyword">return</span> p.top();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (p.top() + q.top()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt; p; <span class="comment">//大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q; <span class="comment">//小顶堆</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p><a href="https://www.nowcoder.com/questionTerminal/9be0172896bd43948f8a32fb954e1be1" target="_blank" rel="noopener">还有一个神仙做法是可以通过AVL数来做</a></p><p>思路：构建一棵”平衡二叉搜索树 “。<br>每个结点左子树均是小于等于其value的值，右子树均大于等于value值。每个子树均按其 “结点数” 调节平衡。 这样根节点一定是中间值中的一个。若结点数为奇数，则返回根节点的值；若结点个数为偶数，则再从根结点左子数或右子数中个数较多的子树中选出最大或最小值既可。</p><font color="red">按照节点数来调节平衡,很神奇的做法</font><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">链接：https:<span class="comment">//www.nowcoder.com/questionTerminal/9be0172896bd43948f8a32fb954e1be1</span></span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line">struct myTreeNode</span><br><span class="line">&#123;</span><br><span class="line">    int val;</span><br><span class="line">    int count;<span class="comment">//以此节点为根的树高</span></span><br><span class="line">    struct myTreeNode* left;</span><br><span class="line">    struct myTreeNode* right;</span><br><span class="line">    myTreeNode(int v) :</span><br><span class="line">        val(v),</span><br><span class="line">        count(<span class="number">1</span>), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">myTreeNode *root = NULL;</span><br><span class="line"> </span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*计算以节点为根的树的高度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    int totalCount(myTreeNode* node)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == NULL)</span><br><span class="line">            return <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="function"><span class="title">return</span> node-&gt;</span>count;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//左左</span></span><br><span class="line">    void rotateLL(myTreeNode* &amp;t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">myTreeNode</span>* k = t-&gt;</span>left;</span><br><span class="line">        myTreeNode* tm = NULL;</span><br><span class="line">        <span class="function"><span class="title">while</span> (k-&gt;</span>right != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">k</span>-&gt;</span>count--;</span><br><span class="line">            tm = k;</span><br><span class="line">            <span class="function"><span class="title">k</span> = k-&gt;</span>right;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">if</span> (k != t-&gt;</span>left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">k</span>-&gt;</span><span class="function"><span class="title">left</span> = t-&gt;</span>left;</span><br><span class="line">            <span class="function"><span class="title">tm</span>-&gt;</span>right = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">t</span>-&gt;</span>left = NULL;</span><br><span class="line">        <span class="function"><span class="title">k</span>-&gt;</span>right = t;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="title">t</span>-&gt;</span><span class="function"><span class="title">count</span> = totalCount(t-&gt;</span><span class="function"><span class="title">left</span>) + totalCount(t-&gt;</span>right) + <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="title">k</span>-&gt;</span><span class="function"><span class="title">count</span> = totalCount(k-&gt;</span><span class="function"><span class="title">left</span>) + t-&gt;</span>count + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">        t = k;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//右右</span></span><br><span class="line">    void rotateRR(myTreeNode* &amp;t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">myTreeNode</span>* k = t-&gt;</span>right;</span><br><span class="line">        myTreeNode* tm = NULL;</span><br><span class="line">        <span class="function"><span class="title">while</span> (k-&gt;</span>left != NULL) &#123;</span><br><span class="line">            <span class="function"><span class="title">k</span>-&gt;</span>count--;</span><br><span class="line">            tm = k;</span><br><span class="line">            <span class="function"><span class="title">k</span> = k-&gt;</span>left;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">if</span> (k != t-&gt;</span>right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">k</span>-&gt;</span><span class="function"><span class="title">right</span> = t-&gt;</span>right;</span><br><span class="line">            <span class="function"><span class="title">tm</span>-&gt;</span>left = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">             </span><br><span class="line">        <span class="function"><span class="title">t</span>-&gt;</span>right = NULL;</span><br><span class="line">        <span class="function"><span class="title">k</span>-&gt;</span>left = t;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="title">t</span>-&gt;</span><span class="function"><span class="title">count</span> = totalCount(t-&gt;</span>left) + <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="title">k</span>-&gt;</span><span class="function"><span class="title">count</span> = totalCount(k-&gt;</span><span class="function"><span class="title">right</span>)+ t-&gt;</span>count + <span class="number">1</span>;</span><br><span class="line">        t = k;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//左右</span></span><br><span class="line">    void rotateLR(myTreeNode* &amp;t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">rotateRR</span>(t-&gt;</span>left);</span><br><span class="line">        rotateLL(t);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//右左</span></span><br><span class="line">    void rotateRL(myTreeNode* &amp;t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">rotateLL</span>(t-&gt;</span>right);</span><br><span class="line">        rotateRR(t);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    void insert(myTreeNode* &amp;root, int x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            root = new myTreeNode(x);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="function"><span class="title">if</span> (root-&gt;</span>val &gt;= x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">insert</span>(root-&gt;</span>left, x);</span><br><span class="line">            <span class="function"><span class="title">root</span>-&gt;</span><span class="function"><span class="title">count</span> = totalCount(root-&gt;</span><span class="function"><span class="title">left</span>)+ totalCount(root-&gt;</span>right) + <span class="number">1</span>;</span><br><span class="line">            <span class="function"><span class="title">if</span> (2 == totalCount(root-&gt;</span><span class="function"><span class="title">left</span>) - totalCount(root-&gt;</span>right))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">if</span> (x &lt; root-&gt;</span><span class="function"><span class="title">left</span>-&gt;</span>val)</span><br><span class="line">                &#123;</span><br><span class="line">                    rotateLL(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    rotateLR(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">insert</span>(root-&gt;</span>right, x);</span><br><span class="line">            <span class="function"><span class="title">root</span>-&gt;</span><span class="function"><span class="title">count</span> = totalCount(root-&gt;</span><span class="function"><span class="title">left</span>)+ totalCount(root-&gt;</span>right) + <span class="number">1</span>;</span><br><span class="line">            <span class="function"><span class="title">if</span> (2 == totalCount(root-&gt;</span><span class="function"><span class="title">right</span>) - totalCount(root-&gt;</span>left))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">if</span> (x &gt; root-&gt;</span><span class="function"><span class="title">right</span>-&gt;</span>val)</span><br><span class="line">                &#123;</span><br><span class="line">                    rotateRR(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    rotateRL(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    void deleteTree(myTreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == NULL)return;</span><br><span class="line">        <span class="function"><span class="title">deleteTree</span>(root-&gt;</span>left);</span><br><span class="line">        <span class="function"><span class="title">deleteTree</span>(root-&gt;</span>right);</span><br><span class="line">        delete root;</span><br><span class="line">        root = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    void Insert(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(root, num);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    double GetMedian()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">int</span> lc = totalCount(root-&gt;</span><span class="function"><span class="title">left</span>), rc = totalCount(root-&gt;</span>right);</span><br><span class="line">        <span class="keyword">if</span> ( lc == rc)</span><br><span class="line">            <span class="function"><span class="title">return</span> root-&gt;</span>val;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            bool isLeft = lc &gt; rc ;</span><br><span class="line">            myTreeNode* tmp ;</span><br><span class="line">            <span class="keyword">if</span> (isLeft)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">tmp</span> = root-&gt;</span>left;</span><br><span class="line">                <span class="function"><span class="title">while</span> (tmp-&gt;</span>right != NULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="function"><span class="title">tmp</span> = tmp-&gt;</span>right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="function"><span class="title">tmp</span> = root-&gt;</span>right;</span><br><span class="line">                <span class="function"><span class="title">while</span> (tmp-&gt;</span>left != NULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="function"><span class="title">tmp</span> = tmp-&gt;</span>left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">return</span> (double)(root-&gt;</span><span class="function"><span class="title">val</span> + tmp-&gt;</span>val) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3&gt;题意&lt;/h3&gt;

&lt;p&gt;如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://statusrank.xyz/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的下一个结点</title>
    <link href="https://statusrank.xyz/2018/07/31/2018-7-31-2/"/>
    <id>https://statusrank.xyz/2018/07/31/2018-7-31-2/</id>
    <published>2018-07-31T07:34:18.000Z</published>
    <updated>2018-07-31T07:48:08.394Z</updated>
    
    <content type="html"><![CDATA[<p></p><h3>题意</h3><br>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。<p></p><a id="more"></a><p></p><h3>思路</h3><br>题意描述的很不好,next指针就是指向父节点的那个。<p></p><ol><li>一个最简单的方法就是跑一遍中序遍历,然后O(N)判断一下即可。</li><li><a href="https://www.nowcoder.com/questionTerminal/9023a0c988684a53960365b889ceaf5e" target="_blank" rel="noopener">这里有个更好的方法</a><br>对于中序遍历我们清楚的知道他的遍历顺序为:”左根右”。那么就可以分为一下三种情况:<br>1)如果当前结点时NULL,则返回NULL<br>2)如果当前结点存在右子树,那么它的下一节点就是从其右孩子开始一直找左孩子,知道找不到为止。<br>3)如果当前结点没有右子树,但他是其父节点的左孩子,则返回父节点。否则就找其父亲的父亲,并判断其是否是父亲的左子树,直到满足这种条件为止,返回其父亲。若找不到则为NULL。<br>(这里考虑到中序遍历的遍历顺序就很好理解了)<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">   给定一个二叉树和其中的一个结点，</span><br><span class="line">   请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using  namespace std;</span><br><span class="line"></span><br><span class="line">struct TreeLinkNode &#123;</span><br><span class="line">    <span class="built_in">int</span> val;</span><br><span class="line">    struct TreeLinkNode *<span class="built_in">left</span>;</span><br><span class="line">    struct TreeLinkNode *<span class="built_in">right</span>;</span><br><span class="line">    struct TreeLinkNode *<span class="keyword">next</span>;</span><br><span class="line">    TreeLinkNode(<span class="built_in">int</span> x) :val(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>), <span class="keyword">next</span>(<span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">/*</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeLinkNode* GetNext(TreeLinkNode* pNode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="literal">NULL</span>) return pNode;</span><br><span class="line">        TreeLinkNode *root = pNode;</span><br><span class="line">        <span class="keyword">while</span>(root -&gt; <span class="keyword">next</span> != <span class="literal">NULL</span>)</span><br><span class="line">        root = root -&gt; <span class="keyword">next</span>;</span><br><span class="line">        gen = tmp = <span class="literal">NULL</span>;</span><br><span class="line">        Inorder(root);</span><br><span class="line">        <span class="keyword">while</span>(gen != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(gen == pNode)</span><br><span class="line">                return gen -&gt; <span class="keyword">next</span>;</span><br><span class="line">            gen = gen -&gt; <span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeLinkNode *gen,*tmp;</span><br><span class="line">    void Inorder(TreeLinkNode *pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="literal">NULL</span>) return ;</span><br><span class="line">        Inorder(pHead -&gt; <span class="built_in">left</span>);</span><br><span class="line">        <span class="keyword">if</span>(gen == <span class="literal">NULL</span>)</span><br><span class="line">            gen = pHead;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmp -&gt; <span class="keyword">next</span> = pHead;</span><br><span class="line">        tmp = pHead;</span><br><span class="line">        tmp -&gt; <span class="keyword">next</span> = <span class="literal">NULL</span>;</span><br><span class="line">        Inorder(pHead -&gt; <span class="built_in">right</span>);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeLinkNode* GetNext(TreeLinkNode* pNode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="literal">NULL</span>) return <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(pNode -&gt; <span class="built_in">right</span> != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeLinkNode *p = pNode -&gt; <span class="built_in">right</span>;</span><br><span class="line">            <span class="keyword">while</span>(p -&gt; <span class="built_in">left</span> != <span class="literal">NULL</span>)</span><br><span class="line">                p = p -&gt; <span class="built_in">left</span>;</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">while</span>(pNode -&gt; <span class="keyword">next</span> != <span class="literal">NULL</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           TreeLinkNode *root = pNode -&gt; <span class="keyword">next</span>;</span><br><span class="line">           <span class="keyword">if</span>(root -&gt; <span class="built_in">left</span> == pNode)</span><br><span class="line">            return root;</span><br><span class="line">           pNode = pNode -&gt; <span class="keyword">next</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       return <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;h3&gt;题意&lt;/h3&gt;&lt;br&gt;给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://statusrank.xyz/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>删除链表中重复的结点</title>
    <link href="https://statusrank.xyz/2018/07/31/2018-7-31-1/"/>
    <id>https://statusrank.xyz/2018/07/31/2018-7-31-1/</id>
    <published>2018-07-31T07:25:57.000Z</published>
    <updated>2018-07-31T07:32:45.224Z</updated>
    
    <content type="html"><![CDATA[<p></p><h3>题意</h3><br>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5<br><a id="more"></a><p></p><p></p><h3>思路</h3><br>简单来讲就是要将所有重复的去掉,然后连接起来。这里通过p1,p2来实现.虽然三个while循环,但是复杂度应该是O(n) 因为每个结点都访问了一次.<p></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">NULL</span> || pHead -&gt; <span class="keyword">next</span> == <span class="keyword">NULL</span>) <span class="keyword">return</span> pHead;</span><br><span class="line">        ListNode *head = <span class="keyword">NULL</span>;</span><br><span class="line">        ListNode *p = <span class="keyword">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(pHead != <span class="keyword">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *p1 = pHead;</span><br><span class="line">            <span class="keyword">while</span>(p1 != <span class="keyword">NULL</span> &amp;&amp; p1 -&gt; <span class="keyword">next</span> != <span class="keyword">NULL</span>  &amp;&amp; p1 -&gt; val == p1 -&gt; <span class="keyword">next</span> -&gt; val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode *p2 = p1;</span><br><span class="line">                <span class="keyword">while</span>(p2 != <span class="keyword">NULL</span> &amp;&amp; p2 -&gt; <span class="keyword">next</span> != <span class="keyword">NULL</span> &amp;&amp; p2 -&gt; val == p2 -&gt; <span class="keyword">next</span> -&gt; val)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//puts("+++");</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; p2 -&gt; val &lt;&lt; '-' &lt;&lt; p2 -&gt; next -&gt; val &lt;&lt; endl;</span></span><br><span class="line">                    p2 = p2 -&gt; <span class="keyword">next</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//puts("***");</span></span><br><span class="line">                p1 = p2 -&gt; <span class="keyword">next</span>;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; p1 -&gt; val &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="keyword">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//puts("--=");</span></span><br><span class="line">                head = p1;</span><br><span class="line">                p = head;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p -&gt; <span class="keyword">next</span> = p1;</span><br><span class="line">                p = p1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p1 == <span class="keyword">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">            pHead = p1 -&gt; <span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两一个简单易写的方法就是可以通过递归实现.<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(pHead == NULL || pHead -&gt;</span> next == NULL) return pHead;</span><br><span class="line">        <span class="function"><span class="title">if</span>(pHead -&gt;</span> <span class="function"><span class="title">val</span> == pHead -&gt;</span> <span class="function"><span class="title">next</span> -&gt;</span> val)</span><br><span class="line">        &#123;</span><br><span class="line">            L<span class="function"><span class="title">istNode</span> *p = pHead -&gt;</span> next;</span><br><span class="line">            <span class="comment">//循环跳过所有和当前值重复的结点,在递归处理下一个结点,最后结果是将所有有重复的结点都删除</span></span><br><span class="line">            <span class="function"><span class="title">while</span>(p != NULL &amp;&amp; p -&gt;</span> <span class="function"><span class="title">val</span> == pHead -&gt;</span> val)</span><br><span class="line">                <span class="function"><span class="title">p</span> = p -&gt;</span> next;</span><br><span class="line">            pHead = deleteDuplication(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="function"><span class="title">pHead</span> -&gt;</span> <span class="function"><span class="title">next</span> = deleteDuplication(pHead -&gt;</span> next);</span><br><span class="line">        return pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;h3&gt;题意&lt;/h3&gt;&lt;br&gt;在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5 处理后为 1-&amp;gt;2-&amp;gt;5&lt;br&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://statusrank.xyz/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>链表中环的入口结点</title>
    <link href="https://statusrank.xyz/2018/07/29/2018-7-29-2/"/>
    <id>https://statusrank.xyz/2018/07/29/2018-7-29-2/</id>
    <published>2018-07-29T12:44:15.000Z</published>
    <updated>2018-07-29T13:10:42.292Z</updated>
    
    <content type="html"><![CDATA[<h3>题意:</h3>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。<a id="more"></a><h3>思路:</h3><p>一个比较简单的方法就是map,或者set一下.第一个重复的就是入口结点,复杂度O(nlogn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *Head = pHead;</span><br><span class="line">        ListNode *ans = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(Head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[Head] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = Head;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mp[Head] = <span class="number">1</span>;</span><br><span class="line">            Head = Head -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    Solution()</span><br><span class="line">    &#123;</span><br><span class="line">        mp.clear();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;ListNode*,<span class="keyword">int</span>&gt;mp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><font color="red">这里还要介绍一个O(N)的做法</font><p><a href="https://www.cnblogs.com/snake-hand/p/3148328.html" target="_blank" rel="noopener">证明可以看这里</a></p><p>方法:<br>这里可以开两个指针,一个是快指针fast,一个是慢指针slow.fast一次走两步,slow一次走一步，则存在定理如果单链表有环那么当二者相遇时一定在环内。则此时将一个指到链表头部,另一个不变，二者同时每次动一格,则当二者再次相遇时即为环的入口节点。如果fast走到null 则无环。</p><p>证明:<br>假设环长度为n,进入环之前结点个数为x,slow在环内走了k个结点,fast绕环走了m圈,则有$ 2(x + k) = x + mn + k $ 可以得到x = mn - k。此时slow距入口结点还剩 n-k个结点,$x = (m - 1)n + n - k$，则可知当二者再次相遇时即为入口结点。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* EntryNodeOfLoop(ListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">NULL</span> || pHead -&gt; <span class="keyword">next</span> == <span class="keyword">NULL</span> || pHead -&gt; <span class="keyword">next</span> -&gt; <span class="keyword">next</span> == <span class="keyword">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">        ListNode *fast = pHead;</span><br><span class="line">        ListNode *slow = pHead;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast -&gt; <span class="keyword">next</span> -&gt; <span class="keyword">next</span>;</span><br><span class="line">            slow = slow -&gt; <span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="keyword">NULL</span>) <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span>(fast != slow)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast -&gt; <span class="keyword">next</span>;</span><br><span class="line">            slow = slow -&gt; <span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3&gt;题意:&lt;/h3&gt;
给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://statusrank.xyz/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>字符流中第一个不重复的字符(队列+思维)</title>
    <link href="https://statusrank.xyz/2018/07/29/2018-7-29-1/"/>
    <id>https://statusrank.xyz/2018/07/29/2018-7-29-1/</id>
    <published>2018-07-29T12:29:21.000Z</published>
    <updated>2018-07-29T12:42:53.951Z</updated>
    
    <content type="html"><![CDATA[<h3>题目描述:</h3><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。<br>输出描述:<br>如果当前字符流没有存在出现一次的字符，返回#字符。<br><a id="more"></a></p><p></p><h3>思路:</h3><br>一个比较好的做法就是,去除插入Insert复杂度肯定为O(N)。求出现一次的第一个字符复杂度为O(C)，C是一个常数，这里我认为复杂度趋近于O(1),空间复杂度O(128)。<p></p><p>具体方法就是利用vis标记数组,标记每个字符出现的次数。对于每个第一次出现的字符将其放入队列中,<br>每次需要找第一个只出现一次的字符就从队列头开始找,如果出现超过一次的直接pop就好了。<br>这样我们可以知道,队列中最多128个字符,也最多pop 128次,其余的都是空的,每次取队列头即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vis[ch - <span class="string">'\0'</span>]++;</span><br><span class="line">        <span class="keyword">if</span>(vis[ch - <span class="string">'\0'</span>] == <span class="number">1</span>)</span><br><span class="line">            Q.push(ch);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!Q.empty() &amp;&amp; vis[Q.front() - <span class="string">'\0'</span>] &gt; <span class="number">1</span>) Q.pop();</span><br><span class="line">        <span class="keyword">if</span>(Q.empty()) <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">return</span> Q.front();</span><br><span class="line">    &#125;</span><br><span class="line">    Solution()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt;Q;</span><br><span class="line">    <span class="keyword">int</span> vis[<span class="number">128</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3&gt;题目描述:&lt;/h3&gt;

&lt;p&gt;请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。&lt;br&gt;输出描述:&lt;br&gt;如果当前字符流没有存在出现一次的字符，返回#字符。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://statusrank.xyz/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
</feed>
