---
title: C++知识点总结
tags: 各种基础知识
abbrlink: 8fbac0b2
date: 2018-08-29 17:30:59
---
***1.c和c++的区别是什么？***
程序 = 数据结构+算法.c语言是面向过程的,面向过程就是分析出解决问题的步骤,然后用函数将其实现,使用时依次调用.

程序= 对象+消息.c++是面向对象的,c++面向对象是将构成问题的事物分解成各个对象，每个对象完成在解决整个问题中的行为.主要特点是类，封装，继承，多态等。面向对象的语言具有更好的可扩展性。
[举例子](https://blog.csdn.net/Edward_Wong/article/details/39533245)

<!--more -->
*** 2.const有什么用途?***
    （1）定义一个常量,即该数据只读,发生更改会报错

    （2）修饰函数返回值和函数的参数,增加程序的健壮性

    （3）修饰函数定义体.(也就是说这个函数为一个只读函数,该函数不会修改任何数据成员的值)

     例如: void getDescription() const; 

    被const修饰过的函数能被const和非const对象调用,但是const对象只能调用被const修饰过的函数定义体.


***3.指针和引用的区别是是什么？***
    （1）引用是变量的一个别名,引用与他所引用的变量实际上代表同一个存储单元

      (2) 引用相比指针对内存的占用少,节省内存空间。

    （3）引用是一个绑定的关系,绑定关系是永久的,而指针可以改变

    （4）常引用的值不能被修改,主要用途是函数的形参以及函数的返回引用



***4.malloc/free 和 new/delete的区别是什么？或者说为什么有了malloc/free 还需要new/delete？***
        (1)new 自动计算要分配的存储区的大小,而malloc需要给出所需要分配的存储区的大小.且new会自动返回正确的指针类型。

      （2）new 可以对分配的存储空间进行初始化，也可以创建对象并对对象进行初始化（创建是调用构造函数,释放时调用析构函数）.

      （3）new/delete可以重载,重载一个与类相关的new/delete运算符.

***5.数据封装、继承、多态***

    数据封装：实现了信息隐蔽性,将数据和数据有关的操作集合封装到一起,用户不必知道其实现细节,只需要知道功能即可。
     继承: 解决了软件的可重用性和可扩展性
     多态性:一个名字或符号具有多种含义,通过重载来实现的. 例如:c++中存在同名函数,根据参数不同自动匹配.

***6.静态成员与静态成员函数***
静态成员属于类,而不属于对象。无论创建多少个该类的对象,都只有一个静态数据的存储空间,静态数据的初始化不会自动进行,必须在类外初始化.。
		类型名 类名:: 静态数据成员[= 常量表达式]
  静态成员函数也属于类而不是某个对象。在类外调用一个公有静态成员函数不需要指明对象或指向对象的指针。方式为: 类名:: 静态公有成员函数名(参数列表)
***7.构造函数、析构函数、拷贝构造函数、友元函数***
    一个类只能由一个析构函数。但却可以有多个构造函数,即可以重载构造函数。<font color = "red">析构函数的调用顺序和构造函数的调用顺序相反</font>
    拷贝构造函数用于创建一个新对象并从已存在的对象中依据规则复制数据。缺省的拷贝构造函数采用内存拷贝的形式，将已经存在对象的内存一个字节一个字节的拷贝到新建对象的内存当中。
    友元函数没有this指针,一个类的友元可以访问该类的所有成员,包括私有和受保护的,这是基于效率的考虑

***8.继承和派生***
  ****派生****:首先是继承基类的成员,再修改和增加派生类具有的自己特性的成员。通过派生,派生类在基类的基础上可以获得可重用性和可扩充性,既具备基类的特征又添加了自己的功能。构造函数和析构函数是不能被继承的。
  ***多重继承***:一个派生类有两个或两个以上的基类。
***继承的意义:***从模块的观点,继承是一种关键的可重用和可扩充技术；从类型的观点,继承的关键是动态匹配。
***公有派生***:
(1)基类的保护成员在派生类中仍然是保护成员
(2)基类的公有成员在派生类中仍然是公有成员
(3)基类的私有成员在派生类中成为不可访问成员
***私有派生***:
(1)基类的保护成员在派生类中仍然是私有成员
(2)基类的公有成员在派生类中仍然是私有成员
(3)基类的私有成员和不可访问成员在派生类中成为不可访问成员
***保护派生***
基类所有公有段和保护段成员在保护派生中成为保护段。
<font color = "red">保护段的作用:
保护派生使得基类的一些成员,他们可以被派生类访问,但不能被其他类访问(类内访问)。也就是说除了基类和他的派生类可以看到这部分成员外,对其他类如同私有段成员函数一样。
</font>
<font color = "red">***基类和派生类共享基类的static成员,要求访问静态成员比用"类名::成员"显示的访问***</font>

派生类的对象创建的时候一定会调用构造函数初始化该类对象,且一定会先调用基类的构造函数(首先基类,其次对象成员,最后派生类),执行析构函数的顺序是相反的。
***访问声明***
仅适用于私有派生,且不能说明任何类型。
类D从基类B中私有派生,则D的派生类E不能访问基类B中的任何成员,为了满足需要可以采用访问声明,使得B的几个成员可以被E访问。
即在类D中重新声明从基类B中继承的几个成员的类型:
基类类名:基类保护段或公有段数据成员
基类类名:基类保护段或公有段成员函数
***9.抽象类***

	抽象类指的是含有纯虚函数的类，该类不能建立对象，只能声明指针和引用，用于基础类的接口声明和运行时的多态 另外，如果抽象类的某个派生类在向继承体系的根回溯过程中，并不是所有的纯虚函数都实现了，该类也是抽象类，同样不能建立对象。

<h3>虚基类</h3>
防止有多个间接基类的多个实例。
***虚基类构造函数的调用次序***
虚基类的构造函数在非虚基类之前调用
若同一层次中包含多个虚基类,虚基类构造函数按他们的说明顺序调用
若虚基类由非虚基类派生,则遵守先调用基类构造函数再调用派生类构造函数的规则
<h3>11.虚函数</h3>
虚函数是一种在基类函数中定义为virtual的函数,并在一个或多个派生类中再定义的函数。虚函数的特点是，只要定义一个基类的指针，就可以指向派生类的对象。
注：无虚函数时，遵循以下规则：C++规定，定义为基类的指针，也能作指向派生类的指针使用，并可以用这个指向派生类对象的指针访问继承来的基类成员；但不能用它访问派生类的成员。

<font color = "red">使用虚函数实现运行时的多态性的关键在于：必须通过基类指针访问这些函数。</font>
一旦一个函数定义为虚函数，无论它传下去多少层，一直保持为虚函数.
把虚函数的再定义称为过载（overriding）而不叫重载（overloading）。
**纯虚函数：**是定义在基类中的一种只给出函数原型，而没有任何与该基类有关的定义的函数。纯虚函数使得任何派生类都必须定义自己的函数版本。否则编译报错。
纯虚函数定义的一般形式：

Virtual type func_name(参数列表)=0; 虚函数要求参数列表类型返回值完全一样!

<font color = "red">
重载一般函数式,函数的返回类型和参数列表可能是不同的,仅仅要求函数名相同。
重载虚函数时,要求函数名、返回类型、参量个数、参数类型和顺序是完全相同的,若仅仅是函数名相同,C++会认为这是一般的函数重载,那么此时虚函数特性就会消失.
</font>

l  含有纯虚函数的基类称为抽象基类。<font color = "red">抽象基类又一个重要特性：抽象类不能建立对象。但是抽象基类可以有指向自己的指针，以支持运行时的多态性。</font>

```
#include <iostream>

#define ECHO(str) std::cout << str

#define ECHOLN(str) std::cout << str<< std::endl

/* run this program using the consolepauser or add your own getch, system("pause") or input loop */

class Base{

         public:

                       virtual void who(){

                        ECHOLN("我是基类！");

                      }

};

class deriv_1:public Base{

         public:

                   voidwho(){

                            ECHOLN("我是子类deriv_1");

                   }

                  

         };

class deriv_2:public Base{

         public:

                  void who(){

                            ECHOLN("我是子类deriv_2");

                   }

};

 

int main(int argc, char** argv) {

         classBase *b,b0;

         classderiv_1 d1;

         classderiv_2 d2;

        

         b= &b0;

         b->who();

        

         b= &d1;

         b->who();

        

         b= &d2;

         b->who();

        

         return0;

}

 
```
输出：

我是基类！

我是子类deriv_1

我是子类deriv_2
###堆和栈的区别:
栈:由编译器自动分配释放,存放函数的参数值,局部变量,函数的返回值等等。
堆: 一般由程序员分配释放,若程序员不释放程序结束时OS可能会回收,主要存放动态分配的内存空间。
全局区（静态区）（static）: 全局变量和静态变量.
[看我这个博客](https://blog.csdn.net/HowardEmily/article/details/63291766)