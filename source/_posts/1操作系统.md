---
title: 操作系统知识点总结
tags: 各种基础知识
mathjax: true
copyright: true
categories: 各种基础知识
abbrlink: '58427e42'
date: 2018-08-30 18:56:01
update:
---
###可重定位分区分配 

  在连续分配方式中，必须把一个系统或用户程序装入一连续的内存空间。如果在系统中只有若干个小的分区，即使它们的容量总和大于要装入的程序，但由于这些分区不相邻接，也无法把该程序装入内存。这种不能被利用的小分区称为“零头”或“碎片”。
<!--more-->
当内存中出现几个互不相邻的小分区,他们单独的容量不能满足要求,但他们的总容量和大于作业的要求,<font color = "red">这时就可以将内存中的所有作业进行移动,使他们全部相邻接,这样就把原来的小分区拼接成大分区来满足要求。</font>
  第一种方案是在某个分区回收时立即进行拼接，这样在内存中总是只有一个连续的空闲区。但由于拼接很费时间，拼接频率过高会使系统开销加大。
  第二种方案是当找不到足够大的空闲区且空闲区的总容量可以满足作业要求时进行拼接。拼接的频率比第一种要小得多，但空闲区的管理稍微复杂一些。 （需要重定位寄存器）

###进程和线程的区别 
进程是运行时的程序,是系统进行资源调度和分配的基本单位,实现了操作系统的并发。
线程是CPU调度和分配的基本单位,一个进程至少有一个线程,线程是依赖于进程存在的。
进程在执行过程中拥有独立的内存单元,而多个线程共享进程的内存。
###进程间通信的方式 
进程通信,即进程间进行数据交换。
####管道
管道是一种供内存共享的外存文件,主要是用于连接一个写入进程和一个读出进程以实现他们之间的数据通信。
管道分为无名管道和有名管道。
1.互斥问题。管道文件应看成临界资源,对管道文件的访问应该互斥的进行。当一个进程对管道读/写时,另一个进程不可以访问他。
2.同步
先写后读,读完才能继续写.
####消息队列
消息队列是消息的链接表,具有写权限的进程可以按照一定的规则向消息队列中添加信息；对消息队列有读权限的进程可以从消息队列中读取信息。
####共享内存
多个进程可以访问同一块内存空间,不同进程可以及时看到对方进程中对共享内存数据的更新。这种方式需要依靠某种同步操作,如互斥锁和信号量等。
####信号量
进程之间及同一种进程的不同线程之间取得同步和互斥的手段
####套接字
可以用于网络中不同机器之间的进程间通信
###线程同步的方式 
互斥量:采用互斥对象机制,只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个,所以可以保证公共资源不会被多个线程同时访问。
信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作
###什么是死锁？死锁产生的条件？ 
1)死锁的概念
在两个或多个并发进程中,存在这样一组进程;每个进程都持有某种资源而又等待其他进程所占有的资源,在未改变状态前这些进程都不能前进,陷入了无休止的等待。
2）产生死锁的原因、产生死锁的条件
互斥条件。进程请求的资源属于临界资源,每次只能允许一个进程使用
不剥夺条件。进程获得某个资源后就一直占有，直到使用完后才释放
请求和等待条件。允许进程在保持已有资源不释放的情况下进一步请求新的资源,若请求的资源得不到满足将会阻塞,也不释放自己所持有的资源
环路条件。若干进程之间形成了一种头尾相连的环形等待资源关系.
###死锁的处理基本策略和常用方法 
解决死锁的方法有死锁预防、死锁避免、检测死锁、解除死锁等。
####死锁预防
基本思想<font color = "red">只要确保死锁发生的四个必要条件至少有一个不成立即可</font>
1)***打破“请求和保持条件”***
一次性分配方案:在进程创建开始时将整个运行期间所需的全部资源一次性分配到手,其运行过程中不许再追加申请。
这种方法简单易行,但是会造成资源浪费,大部分时间里全部分配的资源是闲置不用的,这就造成了浪费。其次,很多情况下我们无法预知一个进程执行前所需的全部资源,因为进程是动态执行的,不可预知的；同时降低了程序的并发性。
2)***打破不可剥夺条件***
一个进程不必一次性地申请全部所需资源,允许采用动态申请的方式;但是当申请的资源得不到满足时就释放自己所占有的全部资源使得其他进程使用。
实现起来复杂,使系统开销增加。
3）***打破环路条件***
实行资源的有序分配。对所有资源编号,所有进程对资源的请求必须严格按照资源序号递增提出,即占有了小号资源才能申请大号资源,这样就不产生回路，预防死锁的发生。
####死锁避免
基本思想:动态监测资源分配状态,以确保循环等待条件不成立,从而确保系统处于安全状态。
安全状态:系统是否存在一个进程序列,使得系统按此序列执行时,所有进程都能到达终点。
***银行家算法***
在运行中实现动态测试,决定是否满足用户当前的需求，系统开销大。
####死锁检测
死锁定理:系统状态S为死锁状态的充要条件是,S状态的资源分配图是不可化简的。
####死锁消除
死锁消除的方法有:撤销进程法和资源剥夺法.
1）撤销进程法
撤销部分死锁的进程,用释放出来的资源救活其他死锁的进程。每撤销一个进程就采用死锁检测的方法检测死锁是否解除,若不解除继续撤销进程直到死锁解除为止。
2）资源剥夺法
将一个阻塞进程挂起后,剥夺该进程所有占有的资源,并保存他在挂起点前的状态,在以后该进程被激活时从以前的状态处继续执行.
####死锁和饥饿的区别?
饥饿是指进程长时间的等待而得不到执行,当饥饿到一定程度的进程所赋予的任务即使完成也不再具有实际意义时称该进程被饿死。
死锁是指多道程序系统中,一组进程中的每一个进程都无限等待,进程所需的资源被另一个进程所占有且永远不会释放。
**死锁进程数大于等于两个,而饥饿或饿死的进程可能只有一个。**
在饥饿的情况下系统可能至少一个进程能正常运行,只是饥饿的进程得不到执行的机会。而死锁则可能会最终导致整个系统陷入死锁并崩溃。
饥饿不一定导致死锁,但至少有一个进程的执行被无限期的推迟。
处于饥饿状态的进程可以是一个就绪进程,处于死锁的进程必定是一个阻塞进程。

###进程有哪些状态？ 
就绪态、运行态、阻塞态、挂起态、退出态
###分页和分段有什么区别(内存管理)? 
####分页
将内存空间划分为一些大小相同的存储块————"帧"
进程划分为与帧同样大小的块称为—————"页面"，每一页面放入一帧中，<页号，页内地址>
页表:为每一个进程建立的表,对应记录着每一页放在哪一帧中。
####分段
一个进程可以由很多段组成,各个段长度并不一定相同,所以为每个段分配等长的存储空间是不现实的,所以采用动态分区分配的机制,根据各个段的长度给予分配大小不等的一些存储块,并允许进程被放在不连续的空间中
####两者的不同点
1.分页不存在外碎片,但是会产生内碎片。分段会产生外碎片,没有内碎片
2.大小:页的大小固定且由系统决定,而段的长度不固定,由其所完成的功能决定
3.地址不同:段向用户提供二维地址空间,页向用户提供一维地址空间
###操作系统中进程调度策略 
**FCFS(先来先服务，队列实现，非抢占的)**：先请求CPU的进程先分配到CPU （有利于长作业不利于端短作业因为长作业占据时间长）
**SJF(最短作业优先调度算法)：**每次从就绪队列中选取估计运行时间最短的进场。
平均等待时间最短，但难以知道下一个CPU区间长度,长作业的运行时间得不到保证
**优先级调度算法（FPF）**(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿
**高响应比优先**:优先级随着等待时间的增加而以速率a提高,则长作业在等待一段时间后必然会有机会被处理。
$R_p = \frac{等待时间+预计执行时间}{预计执行时间} = \frac{响应时间}{预计执行时间}$
**时间片轮转调度算法(可抢占的)**：队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。
**多级队列调度算法：**将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。
**多级反馈队列调度算法**：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。
###什么是虚拟内存? 
***虚拟内存的基本思想:***每个进程拥有独立的地址空间,这个空间被分为大小相等的多个块,称为页(page),每个页都是一段连续的地址,这些页被映射到物理内存,但并不是所有的页必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时,由硬件立刻进行必要的映射;当程序引用到一部分不再物理内存中的地址空间时,由操作系统负责将缺失的部分装入物理内存。<font color = "red">对于进程而言,逻辑上有很大的内存空间,实际上其中一部分对应物理内存上的帧,还有一些并没有加载到内存上而是保存在磁盘中</font>
{% asset_img 1.jpg%}
由上图可以看出虚拟内存实际上比物理内存大。当访问虚拟内存时,会访问内存管理单元(MMU)，去匹配对应的物理地址。***如果虚拟内存的页并不存在于物理内存中,会产生缺页中断,从磁盘中读出放入内存,若内存满还会使用相应的页面置换算法.***
####页面置换算法
1.先进先出FIFO。
2.最近最久未使用LRU,根据使用时间到现在的长短来判断
3.最少使用次数LFU,根据使用次数来判断
4.最优置换算法OPT，就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。
5.clock算法
设置一个访问位 A,A = 0 表明该页最近未访问,A = 1表明该页最近访问过。
当需要置换页时: 旋转一周,找到一个A = 0 的将其置换出去,若A = 1该页不置换,但需要将A置成0,直到找到一个A=0的为止。
6.改进的clock算法
我们可以观察到,如果置换一个修改过的页比置换一个未修改的页麻烦。因为被修改的页需要重新写回外存。所以这里我们增加一个修改位M。
A=0,M=0该页最近未被访问,未修改
A=0，M=1该页最近未被访问，但被修改了
A=1，M=1该页最近被访问了但是没修改
A=1,M=1该页最近被访问了也被修改了。
当需要置换页时:
第一圈:找到一个A=0,M=0的并将其置换出去。
若没有这样的页,则找到一个A=0，M=1的将其置换出去；在这个过程中需要将A=1的置为A=0.循环以上直到找到满足条件的页为止
####局部性原理
时间:最近被访问的页在不久的将来还会被访问
空间:内存中被访问的页周围的页也很可能被访问
###缓冲管理 
外部设备和CPU之间存在速度上的差异,为了缓解差异引入缓冲技术。
####引入缓冲技术的优点
1.减少磁盘的驱动次数
2.可以缓解I/O对缺页置换策略的干扰
3.缓解CPU与外设速度不匹配的矛盾,使数据处理速度提高
####缓冲池技术
缓冲池:一种可以被多用户,多任务共享的缓冲区,是系统提供的一种共享结构,不归进程所有。
1.缓冲池由三个队列组成:
空闲缓冲队列emq。挂有全部克用的空闲缓冲块。
输入队列inq。挂有装满输入数据的缓冲块。
输出队列outq。挂有装满输出数据的缓冲块。
####缓冲区四种工作方式
{% asset_img 2.jpg%}
收容输入,提取输入,收容输出,提取输出
###堆栈内存分配
为了说明这个问题，我们先来看一下内存内部的组织情况{% asset_img 3.jpg%}
####栈区
由编译器自动分配释放,存放函数的参数值,局部变量的值等,内存分配是连续的。即，所分配的内存是在一块连续的内存区域内．当我们声明变量时，那么编译器会自动接着当前栈区的结尾来分配内存．
在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。
####堆区
一般由程序员分配释放， 若程序员不释放，程序结束时可能由操作系统回收．类似于链表，在内存中的分布不是连续的，它们是不同区域的内存块通过指针链接起来的．一旦某一节点从链中断开，我们要人为的把所断开的节点从内存中释放．
堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。
####全局区
全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 程序结束后由系统释放