---
title: Dual Metric Space Learning for Modeling Heterogeneous User Behaviors
copyright: true
mathjax: true
tags:
  - RS
categories: 推荐
abbrlink: cdf3f0c1
date: 2018-11-13 20:55:17
updated:
---
一个成功的行为模型应该考虑用户动作的异构类型之间的相互作用而不是在每种动作类型中建模用户的行为。
OCCF的传统方法都是以得分学习为基础，如MF,TF。他们的目标都是去近似观察到的矩阵(张量)每一项的得分来进行预测。得分学习存在固有的限制,那就是在他们的潜在空间无法正确捕获user-user,item-item之间的相似度关系,因为他们只学到了user-item交互的得分。
为了克服这些限制,最近的相关工作开始学习一个满足三角不等式的度量空间,并且他们尝试去学习距离而不是得分。CML等
<!--more-->
##相关工作
这里我们简单回顾下OCCF的两种用户行为建模的不同方法。一种是score learning,从一个得分函数学习实体间的交互。另一种是Metric Learning方法,从一个距离函数学习。
###隐式张量分解
TF在多方面数据中被广泛的用来分析实体之间的潜在关系,其自然的表为高阶张量。对于异构用户行为建模,它分解为一个用户历史行为的第三阶张量,由三方面组成:users,items,action types.
在早期工作中，RTF（Rendle等人，2009a）使用优化标准来最大化TF的排名AUC，并且BPR-PITF（Rendle等人2009b; Rendle和SchmidtThieme 2010）将BPR概念结合到TF中，其学习了 成对排名使得观察到的条目具有比未观察到的条目更大的分数.BPR-PITF通过将得分函数公式话,引入PIF:
{% asset_img 1.png %}
SPTF 是目前OCCF中最好的张量分解方法。
SPTF也使用PIF计算了每个条目的得分,但是它的损失韩式是基于概率生成模型而不是BPR框架。通过在SGD中很好的采样策略的帮助,它在为异构用户行为建模开发的所有score learning方法中实现了最佳性能。
###CML
[关于CML可以看这里](https://statusrank.xyz/2018/11/13/CML/)
CML的整个过程可以看上面我的这篇博客。
然而,CML只是关注仅仅包含了单一用户动作类型的用户历史数据,所以它学习到的user和item的距离是忽略了交互类型。因此,它不能共同建模多种类型的用户动作之间的相互作用。另外,user-user和item-item相似度只是通过user-item的交互来捕获的,这很naive。这使得度量空间无法学习user-user和item-item的高阶相似度。例如,两个有完全不同行为模式的用户在度量空间中有可能被放置的很近,因为两个用户通常都会在一些物品上执行操作。这是CML直接使用欧几里得距离去测量user-item交互对的相似度。为了克服CML的这些局限性,我们需要**同时考虑异构动作类型和实体之间的非线性关系来设计新的距离函数。**
##双度量空间学习
###问题
我们专注于**给定隐式的用户历史数据我们预测用户未来的行为。**
User set $ U = \{u_1 ,u_2 ,...,u_I \}$
Item set $ V = \{v_1 ,v_2 ,...,v_J \}$
action type set $ T = \{t_1 ,t_2 ,...,t_K \}$
他们三个是每个动作的组成部分,我们称它们为实体。一个单一的动作通过三元组来表示$(user_{index},item_{index},action_{index})$,它要么是能观察到的要么不是。**需要注意的是所有可能的动作是非常大的($I \times J \times K$),可以观察到的动作只占他们其中的一小部分**。包含所有观察到的动作的整个数据集由$X$表示，基于异构用户行为数据集$X$,我们的问题定义为:(异构行为预测)
**给定一个目标用户$u_i$和一个动作类型$t_k$,我们的目标是去预测$u_i$执行动作$t_k$时的Top-n items。**

###行为预测的度量学习
为了加入异构用户动作类型到模型中来我们提出了双度量空间。如图{% asset_img 2.png %}
我们的双度量空间与其他的已经存在的空间的最大不同之处在于捕获实体之间相互作用的空间与实体之间相似性空间的解耦。这种双重结构有利于DualMet学习更准确的空间,它们都为自己的目的学习相互作用或者相似性,并且还对两个空间的关系也进行了额外的训练。
**entities space:**所有的实体embedded,实体之间的相似度被表示为实体之间的距离。
**Behavior space:**embed所有可能的动作(observe or unobserve)和所有用户的行为模型。$a(i,j,k)$表示 单个动作向量(i,j,k),$b(i,k)$表示对于行为类型k,用户i的行为模型向量。
每个$b(i,k)$可以表示为其所有相关动作的表示向量  $\{a(i,j,k) |j = 1,...,J\}$
从某种意义上来说,所有观察到的动作围绕其相应的行为模型聚集在一起,而所有未观察的动作都被推离其行为模型。最后目标动作$a(i,j,k)$与其在空间中的行为模型$b(i,k)$之间的欧式距离意味着**用户i对item j进行动作k的可能性,它们的距离越近,动作就越有可能发生。**
一个主要挑战是如何获得$a(i,j,k)$和$b(i,k)$以便他们能反映实体之间的相互作用。所以这里我们**将动作向量和行为模型向量定义为相应实体向量的线性变换**。
使用了两个非线性映射函数$f$和$g$使得所有可能的动作和用户的行为模式嵌入到行为空间。
$f(u_i,v_j,t_k)$计算动作向量$(i,j,k)$ ,$g(u_i,t_k)$计算用户i的第k类动作类型的代表向量。 $u_i,v_j,t_k$分别对应与实体空间中的user,item,action type.

**我们定义如下距离函数，即计算目标动作和其对应的行为模型之间的欧式距离**:
{%asset_img 3.png %}
为了使这个距离能够反映行动执行的可能性,我们学习了双重度量空间使得观察到的动作比未观察到的动作更接近行为模型。我们建立一个三元组如下:
{% asset_img 4.png %}
{% asset_img 5.png %}
和CML一样$f,g$由MLP+dropout学习的来,因为他能够有效的学习输入特征之间的非线性相互作用,并且结构简单。
###正则化
pull regularizer:有助于观察到的动作接近于其行为模型。上面的损失函数只保证了 observed-unobserved 之间的关系,并没有保证observed和其行为模型之间的距离。函数如下:
{% asset_img 6.png %}
同样的执行和CML中一样的操作,将所有的实体进行标准化。{% asset_img 7.png %}
最后我们得到的目标函数如下:
{% asset_img 8.png %}
算法流程:{% asset_img 9.png %}
###三元组的选择
随着模型逐渐收敛,减少Eq(4)的损失函数的损失变得很困难,因为大量的已经满足边界margin条件的observed-unobserved pair再增加。
边界条件:
$$
d(i,j,k) + \alpha <= d(i,j',k) \tag7
$$
简单的随机选择pair肯定是不行的.
所以这里作者提出了一种优化方法可以高效的找到满足条件的三元组(非0梯度的)。
如图:
{% asset_img 10.png %}
具体流程如下: 
给定用户和动作类型,我们通过对用户未执行动作的一小部分负item进行采样来构造1）观察到的动作集合$V^+$2)未观察到的动作集合$V^-$，对于两个集合中所有的动作按照其$d(i,j,k)$降序排序.
然后分别从两个集合的第一个元素开始找,因为降序排序,所以第一个不满足不等式的pair,后面的全都不满足了。
算法2流程如下:{%asset_img 11.png %}
