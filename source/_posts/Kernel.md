---
title: 机器学习中核函数的理解
copyright: true
mathjax: true
tags:
  - 机器学习
  - Kernel
categories: 机器学习
abbrlink: 55a565c2
date: 2018-11-02 10:11:22
updated:
---
本文大部分内容都是我对各位大神的整合理解,具体问题B乎上都有[问题1](https://www.zhihu.com/question/24627666)
[问题2](https://www.zhihu.com/question/30371867)
里面各位大佬回答的都很不错,这里感谢各位群巨!!! 
核函数**就是在我们将低维非线性可分的数据通过函数$\Phi(x)$映射到高维空间之后计算内积的一种简便方法。**在这里它和映射没有任何关系。
<!--more-->
##低维到高维线性可分的映射
下面这张图位于第一、二象限内。我们关注红色的门，以及“北京四合院”这几个字下面的紫色的字母。我们把红色的门上的点看成是“+”数据，紫色字母上的点看成是“-”数据，它们的横、纵坐标是两个特征。显然，在这个二维空间内，“+”“-”两类数据不是线性可分的。
{% asset_img 1.jpg %}
我们现在考虑核函数$K(v_1,v_2) = \langle v_1,v_2\rangle^2$，即“内积平方”。这里面$v_1=(x_1,y_1), v_2=(x_2,y_2)$是二维空间中的两个点。可以验证，
{% asset_img 2.png %}
在P这个映射下,原来的二维空间中的图在三维空间中的像这个样子:{% asset_img 3.jpg %}
注意到绿色的平面可以完美地分割红色和紫色，也就是说，两类数据在三维空间中变成线性可分的了。

而三维中的这个判决边界，再映射回二维空间中是这样的：{% asset_img 4.jpg %}
** 这是一条双曲线,他不是线性的**
上面这个例子就是将一个二维非线性可分的例子映射到三维空间后变为了一个线性可分的。但是核函数的作用好像并不太明显,因为三维的对我们来说计算内积也很容易。
##核函数
我们再来看另一个例子:
由上面的例子,我们可以看出核函数的定义:
$K(x,y) = \langle f(x),f(y)\rangle$ ,其中x,y是n维的输入值,$f(.)$是从n维到m维的映射(通常m远大于n)。$\langle x,y\rangle = x^Ty$就是内积(全程无法使用尖括号)。严格来说应该叫欧式空间的标准内积，也就是很多人常说的点积（dot product）。
显然,$f(x)$表示的就是将n维x映射到m维后的新坐标或者新向量,那么要计算x和y映射到m维后的内积我们就需要先计算$f(x)$和$f(y)$,然后才能求内积。然而我们发现x或y经过映射后**维数都大大增加，计算内积的成本可能会非常之大，而且在高维空间计算内积，内积又是一个标量，相当于说又把我们的计算从高维空间拉回到一维空间。**所以核函数就是一个帮助我们不需要在高维空间就能计算内积的简化方法。
例如:
令$x = (x_1,x_2,x_3,x_4);y = (y_1,y_2,y_3,y_4)$
令
$f(x) = (x_1x_1,x_1x_2,x_1x_3,x_1x_4,x_2x_1,x_2x_2,$
$x_2x_3,x_2x_4,x_3x_1,x_3x_2,x_3x_3,x_3x_4,x_4x_1,
x_4x_2,x_4x_3,x_4x_4)$
令核函数$K(x,y) = \langle x,y\rangle^2$ 这里依然是表示内积$x^Ty$
假设$x = (1,2,3,4),y = (5,6,7,8)$
那么有
$$
f(x) = (1,2,3,4,2,4,6,8,3,6,9,12,4,8,12,16)
$$
$$
f(y) = (25,30,35,40,30,36,42,48,35,42,49,56,40,48,56,64)
$$

$f(x)^Tf(y) = 25+60+105+160+60+144+252+384+105+252+441$
$+672+160+384+672+1024 = 4900.$
这时我们就发现我们将4维映射到16维后计算量还是很大的,这时候就是我们核函数登场了
$ K(x,y) = (5 + 12 + 21 + 32)^2 = 4900$
根据这个例子我们可以看到,核函数其实就是帮助我们省去在高维空间里进行繁琐计算的"简便运算法"。甚至它能解决无限维空间无法计算的问题。
**我们在计算高维空间的内积时,必须求的$f(x),f(y)$然后求的$f(x)^Tf(y)$,而我们这里就是可以定义核函数$K(x,y) = f(x)^Tf(y)$使得我们在不需要显式计算每一个$f(x)$,甚至不需要知道$f(.)$长什么样子就可以直接求出内积。**
##核矩阵
大家一定都有了解过内积矩阵Gram矩阵。假设我们的数据集中有N个点,那么我们可以定义一个核矩阵(其实就是Gram矩阵),该矩阵中存放的就是这N个点在新空间对应的N个点彼此之间的点积。
{% asset_img 6.png %}
##Mercer定理
Mercer定理是指函数需满足对称性和半正定性(>= 0),所谓对称性就是比如定义中$f(x) \cdot f(y) =f(y) \cdot f(x)  $.而所谓的半正定性就是说核矩阵K所有的特征值非负.
{% asset_img 7.png %}
##一些核函数介绍
一个函数要想成为正定核函数，必须满足他里面任何点的集合形成的Gram矩阵是半正定的。也就是说,对于任意的$x_i \in \chi ， i=1,2,3...m,K(x_i,x_j)$对应的Gram矩阵$K = \bigg[ K(x_i, x_j )\bigg]$是半正定的,则$K(x,z)$是正定核函数。
从上面的定理看，它要求任意的集合都满足Gram矩阵半正定，所以自己去找一个核函数还是很难的，怎么办呢？还好牛人们已经帮我们找到了很多的核函数，而常用的核函数也仅仅只有那么几个。下面我们来看看常见的核函数, 选择这几个核函数介绍是因为scikit-learn中默认可选的就是下面几个核函数。
###线性核函数
线性核函数（Linear Kernel）其实就是我们前两篇的线性可分SVM，表达式为：
$$
K(x, z) = x \bullet z
$$
也就是说，线性可分SVM我们可以和线性不可分SVM归为一类，区别仅仅在于线性可分SVM用的是线性核函数。
###多项式核函数
多项式核函数（Polynomial Kernel）是线性不可分SVM常用的核函数之一，表达式为：
$$
K(x, z) = （\gamma x \bullet z  + r)^d
$$
其中，$\gamma, r, d$需要自己调参。
###高斯核函数
高斯核函数（Gaussian Kernel），在SVM中也称为径向基核函数（Radial Basis Function,RBF），它是非线性分类SVM最主流的核函数。libsvm默认的核函数就是它。表达式为：
$$
K(x, z) = exp(-\gamma||x-z||^2)
$$
其中$\gamma > 0$需要自己调参。
###Sigmoid核函数
Sigmoid核函数（Sigmoid Kernel）也是线性不可分SVM常用的核函数之一，表达式为：
$$
K(x, z) = tanh（\gamma x \bullet z  + r)
$$
其中$\gamma, r$都需要自己调参定义。
