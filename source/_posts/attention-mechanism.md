---
title: attention机制总结
copyright: true
mathjax: true
tags: AM
categories: 推荐
abbrlink: aa707881
date: 2019-06-05 21:44:37
updated:
---
Attention机制的本质来自于人类视觉注意力机制。简单来说，它就是一种**权重参数分配机制，目标是协助模型捕捉重要信息**。
<!--more-->
## Attention Mechanism
具体一点就是，给定一个Query，和一系列的<key,value>对，

 - 将Query于Key进行相似性度量
 - 将求得的相似性度量进行缩放标准化
 - 将权重与value进行加权求和，得到最终的attention数值，$Attention(Q,K,V) = softmax(\frac{QK^T}{\sqrt d_k})V$
 {% asset_img 1.jpg %}
 ## Self-attention
 self-attention与attention类似，是寻找序列内部元素的关系，也就是说Q,K,V是来自同一个输入。
 ## Attention常见实现方法
 ### 多层感知机
 $$
 a(Q,K) = W_2^Ttanh(W_1[Q;K))
 $$
该方法主要是将Q,K拼接，然后一起通过一个激活函数为tanh的全连接层，再跟权重矩阵做乘积。
### Dot Product / scaled-dot Product
$$
a(Q,K) = Q^TK
$$
该方法适用于query与key维度相同情景，通过q转置后与k点积。在权重值过大的情况下，可以将数据标准化，即scaled-dot Product。
### Bilinear
$$
a(Q,K) = Q^TWK
$$
通过一个权重矩阵直接建立query与key的关系，权重矩阵可以随机初始化也可以使用预设的。
### Cosine
$$
S(Q,K_i) = \frac{Q\cdot K_i}{||Q||||K_i||}
$$
即计算两个向量的cosine相似度。
## attention举例
**下面我们简单谈谈文本处理领域的AM模型**。要提文本处理领域的AM模型，就不得不先谈谈Encoder-Decoder框架，因为目前绝大多数文献中出现的AM模型是附着在Encoder-Decoder框架下的，当然，其实AM模型可以看作一种通用的思想，本身并不依赖于Encoder-Decoder模型，这点需要注意。
下图是文本处理领域里常用的Encoder-Decoder框架最抽象的一种表示：
{%asset_img 1.png %}
Encoder-Decoder框架可以这么直观地去理解：可以把它看作适合处理由一个句子（或篇章）生成另外一个句子（或篇章）的通用处理模型。对于句子对<X,Y>，我们的目标是给定输入句子X，期待通过Encoder-Decoder框架来生成目标句子Y。X和Y可以是同一种语言，也可以是两种不同的语言。而X和Y分别由各自的单词序列构成：$X = <x_1,x_2,\dots,x_m>,Y = <y_1,y_2,\dots,y_n>$.
Encoder顾名思义就是对输入句子$X$进行编码，将输入句子通过非线性变换转化为中间语义表示C：$C = F(X)$。
对于解码器Decoder来说，其任务是根据句子$X$的中间语义表示$C$和之前已经生成的历史信息$y_1,y_2….y_{i-1}$来生成$i$时刻要生成的单词$y_i$: $y_i = G(C,y_1,y_2,\dots,y_{i-1})$。
每个$y_i$都依次这么产生，那么看起来就是整个系统根据输入句子$X$生成了目标句子$Y$。
  Encoder-Decoder是个非常通用的计算框架，至于Encoder和Decoder具体使用什么模型都是由研究者自己定的，常见的比如CNN/RNN/BiRNN/GRU/LSTM/Deep LSTM等，这里的变化组合非常多.
## 加入attention
上图展示的Encoder-Decoder模型是没有体现出“attention”的，所以可以看成是一个分心模型。为什么说它注意力不集中呢？请观察下目标句子$Y$中每个单词$y_i$的生成过程如下：
$$
y_1 = f(C) \\
y_2 = f(C,y_1) \\
\dots \\
y_i = f(C,y_1,y_2,\dots,y_{i-1})
$$
其中$f$是decoder的非线性变换函数。
从这里可以看出，在生成目标句子的单词时，**不论生成哪个单词，是$y_1,y_2$也好，还是$y_3$也好，他们使用的句子$X$的语义编码$C$都是一样的，没有任何区别。而语义编码$C$是由句子$X$的每个单词经过Encoder 编码产生的，这意味着不论是生成哪个单词，$y_1,y_2$还是$y_3$，其实句子$X$中任意单词对生成某个目标单词$y_i$来说影响力都是相同的，没有任何区别**（其实如果Encoder是RNN的话，理论上越是后输入的单词影响越大，并非等权的)
这就是为何说这个模型没有体现出注意力的缘由。这类似于你看到眼前的画面，但是没有注意焦点一样。如果拿机器翻译来解释这个分心模型的Encoder-Decoder框架更好理解，比如输入的是英文句子：Tom chase Jerry，Encoder-Decoder框架逐步生成中文单词：“汤姆”，“追逐”，“杰瑞”。在翻译“杰瑞”这个中文单词的时候，分心模型里面的每个英文单词对于翻译目标单词“杰瑞”贡献是相同的，很明显这里不太合理，显然“Jerry”对于翻译成“杰瑞”更重要，但是分心模型是无法体现这一点的，这就是为何说它没有引入注意力的原因。没有引入注意力的模型在输入句子比较短的时候估计问题不大，但是如果输入句子比较长，此时所有语义完全通过一个中间语义向量来表示，单词自身的信息已经消失，可想而知会丢失很多细节信息，这也是为何要引入注意力模型的重要原因。
上面的例子中，如果引入AM模型的话，应该在翻译“杰瑞”的时候，体现出英文单词对于翻译当前中文单词不同的影响程度，比如给出类似下面一个概率分布值：
$$
（Tom,0.3）(Chase,0.2)(Jerry,0.5)
$$
每个英文单词的概率代表了翻译当前单词“杰瑞”时，注意力分配模型分配给不同英文单词的注意力大小。这对于正确翻译目标语单词肯定是有帮助的，因为引入了新的信息。同理，目标句子中的每个单词都应该学会其对应的源语句子中单词的注意力分配概率信息。这意味着在生成每个单词$y_i$的时候，原先都是相同的中间语义表示$C$会替换成根据当前生成单词而不断变化的$C_i$。理解AM模型的关键就是这里，即**由固定的中间语义表示C换成了根据当前输出单词来调整成加入注意力模型的变化的$C_i$**。增加了AM模型的Encoder-Decoder框架理解起来如图2所示。
{% asset_img 2.png %}
即生成目标句子单词的过程成了下面的形式：
$$
y_1 = f_1(C_1) \\
y_2 = f_1(C_2,y_1)\\
y_3 = f_1(C_3,y_1,y_2) \\
\dots
$$
而每个$C_i$可能对应着不同的源语句子单词的注意力分配概率分布，比如对于上面的英汉翻译来说，其对应的信息可能如下：
{% asset_img 3.png %}
其中，f2函数代表Encoder对输入英文单词的某种变换函数，比如如果Encoder是用的RNN模型的话，这个f2函数的结果往往是某个时刻输入xi后隐层节点的状态值；g代表Encoder根据单词的中间表示合成整个句子中间语义表示的变换函数，一般的做法中，g函数就是对构成元素加权求和，也就是常常在论文里看到的下列公式：
$$
C_i = \sum_{j = 1}^{T_x} \alpha_{ij}h_j
$$
假设$C_i$中那个$i$就是上面的“汤姆”，那么Tx就是3，代表输入句子的长度，$h1=f(“Tom”)，h2=f(“Chase”),h3=f(“Jerry”)$，对应的注意力模型权值分别是$0.6,0.2,0.2$，所以$g$函数就是个加权求和函数。如果形象表示的话，翻译中文单词“汤姆”的时候，数学公式对应的中间语义表示$C_i$的形成过程类似下图
{% asset_img 4.png %}
这里还有一个问题：生成目标句子某个单词，比如“汤姆”的时候，你怎么知道AM模型所需要的输入句子单词注意力分配概率分布值呢？就是说“汤姆”对应的概率分布：$（Tom,0.6）(Chase,0.2)(Jerry,0.2）$是如何得到的呢？
为了便于说明，我们假设对图1的非AM模型的Encoder-Decoder框架进行细化，Encoder采用RNN模型，Decoder也采用RNN模型，这是比较常见的一种模型配置
{%asset_img 5.png %}
那么用下图可以较为便捷地说明注意力分配概率分布值的通用计算过程：
{%asset_img 6.png %}
对于采用RNN的Decoder来说，如果要生成yi单词，在时刻i，我们是可以知道在生成Yi之前的隐层节点i时刻的输出值Hi的，而我们的目的是要计算生成Yi时的输入句子单词“Tom”、“Chase”、“Jerry”对Yi来说的注意力分配概率分布，那么可以用i时刻的隐层节点状态Hi去一一和输入句子中每个单词对应的RNN隐层节点状态hj进行对比，即通过函数F(hj,Hi)来获得目标单词Yi和每个输入单词对应的对齐可能性，这个F函数在不同论文里可能会采取不同的方法，然后函数F的输出经过Softmax进行归一化就得到了符合概率分布取值区间的注意力分配概率分布数值。图5显示的是当输出单词为“汤姆”时刻对应的输入句子单词的对齐概率。绝大多数AM模型都是采取上述的计算框架来计算注意力分配概率分布信息，区别只是在F的定义上可能有所不同。
上述内容就是论文里面常常提到的Soft Attention Model的基本思想，你能在文献里面看到的大多数AM模型基本就是这个模型，区别很可能只是把这个模型用来解决不同的应用问题。那么怎么理解AM模型的物理含义呢？一般文献里会把AM模型看作是单词对齐模型，这是非常有道理的。目标句子生成的每个单词对应输入句子单词的概率分布可以理解为输入句子单词和这个目标生成单词的对齐概率，这在机器翻译语境下是非常直观的：传统的统计机器翻译一般在做的过程中会专门有一个短语对齐的步骤，而注意力模型其实起的是相同的作用。在其他应用里面把AM模型理解成输入句子和目标句子单词之间的对齐概率也是很顺畅的想法。
当然，我觉得从概念上理解的话，把AM模型理解成影响力模型也是合理的，就是说生成目标单词的时候，输入句子每个单词对于生成这个单词有多大的影响程度。这种想法也是比较好理解AM模型物理意义的一种思维方式。
下图是论文“A Neural Attention Model for Sentence Summarization”中，Rush用AM模型来做生成式摘要给出的一个AM的一个非常直观的例子。
{%asset_img 7.png %}
这个例子中，Encoder-Decoder框架的输入句子是：“russian defense minister ivanov called sunday for the creation of a joint front for combating global terrorism”。对应图中纵坐标的句子。系统生成的摘要句子是：“russia calls for joint front against terrorism”，对应图中横坐标的句子。可以看出模型已经把句子主体部分正确地抽出来了。矩阵中每一列代表生成的目标单词对应输入句子每个单词的AM分配概率，颜色越深代表分配到的概率越大。这个例子对于直观理解AM是很有帮助作用的。
