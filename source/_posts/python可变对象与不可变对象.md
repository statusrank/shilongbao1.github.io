---
title: python中的可变对象与不可变对象
copyright: true
mathjax: true
tags: python
categories: 各种基础知识
abbrlink: e59929ab
date: 2019-04-24 16:13:51
updated:
---
# 概念
可变对象与不可变对象的区别在于对象本身是否可变。
python内置类型中

 - 可变对象：列表(list)，字典(dict)，集合(set)
 - 不可变对象：元组(tuple)，string，int，float，bool
 
 <!--more-->
 例如：
 ```python
#可变对象
>>> a = [1, 2, 3]
>>> a[1] = 4
>>> a
[1, 4, 3]
#不可变对象
>>> b = (1, 2, 3)
>>> b[1] = 4
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
```
上面的例子直观的说明了**可变对象是可以直接改变的，不可变对象则不可以。**
# 地址问题
**可变对象发生变化，其指向的地址没有发生改变。**
```python
>>> a = [1, 2, 3]
>>> id(a) # id得出其对应的地址
2139167175368
>>> a[1] = 4
>>> id(a)
213916717536
```
## 可变对象
```python
>>> a = [1, 2, 3]
>>> id(a)
2139167246856
>>> b = a
>>> id(b)
2139167246856
>>> a[1] = 4
>>> a
[1, 4, 3]
>>> b
[1, 4, 3]
>>> id(a)
2139167246856
>>> id(b)
2139167246856
```
可以发现此时两个变量指向同一个地址，改变a则b也跟着改变。（因为他们始终指向同一个地址）
## 不可变对象
```python
>>> a = (1, 2, 3)
>>> id(a)
2139167074776
>>> b = a
>>> id(b)
2139167074776
>>> a = (4, 5, 6)
>>> a
(4, 5, 6)
>>> b
(1, 2, 3)
>>> id(a)
2139167075928
>>> id(b)
2139167074776
```
从上面的例子中可以发现，不可变对象a发生变化后，它的地址也发生了变化，而b维持原来的地址，原来地址中的内容也没有发生变化。
# 作为函数参数
## 可变对象
```python
>>> def myfunc(l):
...     l.append(1)
...     print(l)
...
>>> l = [1, 2, 3]
>>> myfunc(l)
[1, 2, 3, 1]
>>> l
[1, 2, 3, 1]
```
可以看到，**可变对象作为参数传入时，在函数中对其本身进行修改会影响到全局中的这个变量的值。因为上面说到，可变对象直接赋值二者还是指向同一个地址，这样在函数中我们是直接对该地址出的值进行了修改。**
## 不可变对象
```python
>>> def myfunc(a):
...     a += 1
...     print(a)
...
>>> a = 2
>>> myfunc(a)
3
>>> a
2
```
**对于不可变对象来说，虽然函数中的a的值改变了，但是全局中的a值没变。因为不可变对象是无法“直接“修改的，对其进行修改时，它会将该对象复制到另一个地址，然后再另一个地址上进行修改，这样原来地址处的值未发生任何改变。**
```python
a =  3
print(id(a)) # 140713338561232
b = a
print(id(b)) # 140713338561232
a =  4
print(id(4))# 140713338561264
print(b) # 3
print(id(b)) # 140713338561232
```
# 总结
<font color = "red">python中向函数传递参数只能是引用传递，表示把它的地址都传进去了。有的编程语言(c++等)允许值传递，即只是把值传进去，在里面另外找一个地址来放，这样就不会影响全局中的变量。</font>
