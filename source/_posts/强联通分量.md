---
title: 强连通分量以及tarjan算法
tags: ACM
abbrlink: f1ea267d
date: 2018-08-26 20:12:07
---
[参考这里](https://blog.csdn.net/mengxiang000000/article/details/51672725)
[还有这里](https://www.cnblogs.com/nullzx/archive/2017/12/04/7968110.html)

<h1>什么是强连通分量?</h1>

1.强连通分量是相对于有向图来说的,在有向图G中,若任意两个点都可达,则称图G是强连通图。
如果存在两个顶点u和v,u不能到v或者v不能到u,则称图G为强非连通图
2.如果G不是一个强连通图,它的子图G2是强连通图,V属于G2,任意包含V的强连通子图也是G2的子图,那么G2就是G的极大强连通子图,也叫做强连通分量。
<!--more-->
3.所谓强连通,就是图中有两点u和v,使得能够找到有向路径从u到v以及v到u。

<h1>什么是割点和桥(割边)？</h1>
割点和桥的定义是相对于无向图来说的。

割点: 无向连通图中,去掉一个顶点及和它相邻的所有边,图中的连通分量数增加,则该顶点为割点。(也可以理解成使原来的连通部分变得不再连通)
桥(割边):无向连通图中,去掉一条边,图中的连通分量数增加,则这条边成为桥或者割边。
<h2>割点和桥的关系</h2>
有割点不一定有桥,但是有桥一定有割点。也就是说桥一定是与割点相连的边。
如图: {% asset_img 1.png %}

<h1>什么是tarjan算法?</h1>
tarjan算法,其本质是基于dfs的思想,利用dfs遍历得到生成树的访问顺序从而找出在一个强连通分量中的关键节点,从而找到整个强连通分量。
<h3>dfn[] 和low[]</h3>
首先我们需要定义两个数组,这两个数组也是tarjan的核心思想。
dfn[] ，i表示顶点的编号,dfn[i]的值表示该顶点在dfs中的遍历顺序,每访问到一个未访问过的点该点的时间戳就+1.由此在dfs中我们可以得到:子节点的dfn一定大于父节点的dfn,而且在访问一个结点后其dfn便确定了,不会再改变。
low[]，下标表示顶点编号,low的值表示该点所能到达的点的时间戳的最小值。(这个当然是需要回溯维护的)
当然因为子节点的dfn一定大于父节点,所以low值主要维护的自己所能访问的祖先的时间戳的最小值。
我们也是通过它和dfn的关系来判断是否为关键节点。

具体例子请看上面两个博客,都很不错。

根据tarjan算法,当我们遍历完所有u所能到达的子节点时,若有low[u] == dfn[u] 那么这个点就是关键节点,同时也是进入强连通分量的起始节点(我们可以知道强连通分量一定有环的)。

代码只是用来做一个参考:

<h3>如何找到强连通分量中的所有点呢？</h3>
我们知道当遍历完u所有能到达的点再回溯到u时,那么与u无关的点已经出栈；栈顶上这些的点一定是通过u dfs入栈的,我们又说过当满足条件是u是强连通分量的入口结点,所以此时栈顶一直到u出栈，之间这些点都是属于一个强连通分量的。
```
void dfs(int x)
{
    dfn[x] = low[x] = ++_lock;
    st.push(x);
    for(int i = 0;i < vt[x].size();++i)
    {
        int v = vt[x][i];
        if(!dfn[v])
        {
            dfs(v);
            low[x] = min(low[x],low[v]);
        }
        else if(!belong[v])
        {
            low[x] = min(low[x],dfn[v]);
        }
    }
    if(low[x] == dfn[x]) //这一部分是找到强连通分量中的所有点
    {
        ++cnt;
        while(!st.empty())
        {
            int w = st.top();
            st.pop();
            belong[w] = cnt;
            cost[cnt] += a[w];
            if(w == x)
                break;
        }
    }
    return ;
}
void solve() //缩点
{
    for(int i = 1;i <= n;++i)
    {
        for(int j = 0;j < vt[i].size();++j)
        {
            int v = vt[i][j];
            if(belong[i] != belong[v])
            {
                af[belong[i]].pb(belong[v]);
                in[belong[i]]++;
            }
        }
    }
    ll mi = 1e18;
    for(int i = 1;i <= cnt;++i)
    {
        if(in[i] == 0)
        {
            mi = min(mi,cost[i]);
        }
    }
    cout << mi << endl;
    return ;
}
```

<h1>如何利用tarjan算法来求割点或桥？</h1>

我们重新复习下上面我们定义的两个数组,dfn[]表示该顶点在dfs遍历中是第几个被访问的,也可以理解成是时间戳。low[]表示该点所能到达的祖先的最小顺序值(上面说过主要是对祖先起作用)。

那么我们可以得出如下结论:
1.割点:
判断u是否为割点,只需要拿u的dfn值和其所有子节点的low[v]比较,如果low[v]>= dfn[u] 则u为割点。
low[v] >= dfn[u] 这说明v要访问u的祖先顶点必须经过u结点,若不是根据tarjan算法,low值肯定会比dfn[u]小(因为u的祖先一定比u的dfn小)。
2.桥:
判断是否有桥,我们上面说过桥一定是直接和割点相连的。所以我们得出条件: low[v] > dfn[u]有桥。

这里没有等号的原因: 若low[v]==dfn[u] 说明从v可以回到u,也就是说即使删了u到v的边,还存在其他路径是u，v仍然连通。

具体例子请看[here ](https://www.cnblogs.com/nullzx/archive/2017/12/04/7968110.html)