---
title: CCF认证 棋局评估(博弈对抗搜索)
copyright: true
mathjax: true
tags:
  - dfs
  - 博弈
categories: ACM
abbrlink: 13e90b65
date: 2018-09-19 21:57:18
updated:
---
## 题意
[传送门](http://118.190.20.162/view.page?gpid=T70)
{% asset_img 1.png %}
<!--more -->
##思路
典型博弈里的对抗搜索。
1.Alice得分为正数,Bob赢得分为负数
2.对于当前的一个状态,如果是Alice赢那么他一定会让自己得到的分数最大
3.对于当前的一个状态如果Bob赢那么他一定也会让自己得到的分数最大,这里Bob得分为负数所以可以变为Bob让自己得分最小。(最大最小的意思就是找自己能赢状态里的最)
4.这里因为是$3 \times 3$的格子复杂度为$O(9!)$

```C++
#include<bits/stdc++.h>

using namespace std;
const int maxn = 10;
int a[5][5],n;
int Count()
{
    int cnt = 0;
    for(int i = 1;i <= 3;++i)
        for(int j = 1;j <= 3;++j)
        if(!a[i][j])
        cnt++;
    return cnt;
}
int hang(int id,int num)
{
    return a[id][1] == num && a[id][2] == num && a[id][3] == num;
}
int lie(int id,int num)
{
    return a[1][id] == num && a[2][id] == num && a[3][id] == num;
}
int check(int num)
{
    int win = 0;
    if(hang(1,num) ||hang(2,num) ||hang(3,num)) win = 1;
    if(lie(1,num) || lie(2,num) || lie(3,num)) win = 1;
    if(a[1][1] == num && a[2][2] == num &&a[3][3] == num)
        win = 1;
    if(a[1][3] == num && a[2][2] == num && a[3][1] == num)
        win = 1;
    if(!win) return 0;
    int ans = Count() + 1;
    return (num == 1)? ans:-ans;
}
int dfs(int cur)
{
    if(!Count()) return 0;
    int mi = 20,ma = -20;
    for(int i = 1;i <= 3;++i)
    {
        for(int j = 1;j <= 3;++j)
        {
            if(a[i][j]) continue;
            a[i][j]  = cur;
            int flag = check(cur);
            if(flag)
            {
                a[i][j] = 0;
                return (cur == 1)?max(ma,flag):min(mi,flag);
            }
            if(cur == 1)
                ma =  max(ma,dfs(2));
            else
                mi = min(mi,dfs(1));
            a[i][j] = 0;
        }
    }
    return (cur == 2)?mi:ma;
}
int main()
{
    cin >> n;
    while(n--)
    {
        for(int i = 1;i <= 3;++i)
            for(int j = 1;j <= 3;++j)
                scanf("%d",&a[i][j]);
        int x = check(1),y = check(2);
        if(x){cout << x << endl;continue;}
        if(y){cout << y << endl;continue;}
        cout << dfs(1) << endl;
    }
    return 0;
}

```