---
title: 深度学习----神经风格迁移(neural style transfer)
copyright: true
mathjax: true
tags: Deep Learning
categories: 深度学习
abbrlink: e5e71180
date: 2018-10-16 18:38:06
updated:
---
##深度网络学习内容可视化
###如何可视化
假设我们训练了一个卷积神经网络:
{% asset_img 1.jpg %}
<!--more-->
我们在某一层任选一个神经元,然后喂给他大量图片,看哪种图片最能激活该神经元.
我们希望看到不同层的隐藏单元的计算结果。依次对各个层进行如下操作:
(1)在当前层挑选一个隐藏但愿
(2)遍历训练集,找到最大化地激活了该运算单元的图片或者图片块
(3)对该层的其他运算单元执行操作
对于在第一层的隐藏单元中,其只能看到卷积网络的小部分内容,也就是最后我们找到的那些最大化激活第一层隐藏单元的是一些小图片块。我们可以理解为**第一层的神经元通常会寻找一些简单的特征,如边缘或者颜色阴影等**
###各层网络可视化
{% asset_img 2.jpg %}
对于卷积网络的各层单元,随着网络深度的增加,隐藏层计算单元随着层数的增加从简单的事物逐渐到更加复杂的事物。
##神经风格迁移
###什么是神经风格迁移？
{%asset_img 1.png %}
###代价函数
为了实现神经风格迁移,我们需要为生成的图片定义一个代价韩式。
对于神经风格迁移,我们的目标是由内容图片C和风格图片S,生成最终的风格迁移图片G.
{%asset_img 3.jpg %}

$J(G) = \alpha J_{content}(C, G) + \beta J_{style}(S,G)$
其中
$J_{content}(C, G)$  代表生成图片G的内容和内容图片C的内容的相似度；
 $J_{style}(S,G)$ 代表生成图片G的内容和风格图片S的内容的相似度；
$\alpha、\beta$  两个超参数用来表示以上两者之间的权重。
###执行过程
1.随机初始化生成图片G
2.使用梯度下降算法最小化上面定义的代价函数J(G)
{% asset_img 4.jpg %}
对于上图的内容图片C和风格图片S,通过梯度下降算法一次次的训练,我们可以由初始的白噪声图片得到最终的风格迁移图片G。
###内容代价函数$J_{content}(C,G)$
1.假设我们使用隐藏层l来计算内容代价。如果选的l太小,那么代价函数就会使得我们的生成图片G在像素上非常接近内容图片；然而用很深的网络,那么生成图片G中就会产生内容图片中所拥有的物体。所以对于l一般选在网络的中间层,不深也不浅。
2.使用一个预训练的卷积网络(VGG等)
3.令$a^{[l](C)}$和$a^{[l](G)}$分别代表内容图片C和生成图片G的l层激活值
4.如果 $a^{[l](C)} $和 $a^{[l](G)}$ 相似，那么两张图片就有相似的内容
定义内容代价函数如下:
$J_{content}(C, G) = \dfrac{1}{2}||a^{[l](C)} - a^{[l](G)} ||^{2}$
<font color = "red">在对代价函数运行梯度下降算法时,会激励这里的内容代价函数努力使得生成图片G隐藏层l的激活值和内容图片C隐藏层l的激活值相似</font>
###风格代价函数$J_{style}(S,G)$
####style的含义
对于一个卷积网络中,我们选择网络的中间层l,定义style表示l层的各个通道激活项之间的相关性。
{% asset_img 5.jpg %}
####相关性大小的度量
{% asset_img 6.jpg %}
上面是我们选出的l层的激活项,**对于不同的通道值,代表不同的神经元所学习到的特征.**这里加入红色的通道可以找到图片中含有垂直纹理特征的区域,黄色通道可以找出橙色的区域。
我们将相关系数应用到风格图片S和生成图片G的对应通道上，就可以度量风格图片和生成图片的相似度。
####style矩阵
{% asset_img 2.png %}
####代价函数
$$J^{[l]}_{style}(S, G) = \dfrac{1}{2n^{[l]}_{h}n^{[l]}_{w}n^{[l]}_{c}}||G^{[l](S)} - G^{[l](G)} ||^{2}_{F} = \dfrac{1}{2n^{[l]}_{h}n^{[l]}_{w}n^{[l]}_{c}}\sum_{k}\sum_{k'}(G^{[l](S)}_{kk'} - G^{[l](G)}_{kk'})^{2}$$

**内容代价函数和风格代价函数前面的归一化可以加也可以不加，因为总体的代价函数前面有权重系数。**
如果对各层都使用风格代价函数，那么会让结果变得更好：
$J_{style}(S,G) = \sum_{l}\lambda^{[l]}J_{style}^{[l]}(S,G)$

