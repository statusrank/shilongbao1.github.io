---
title: CCF - 行车路线(floyd +spfa)
copyright: true
mathjax: true
tags: 图论
categories: ACM
abbrlink: 7e2da163
date: 2018-09-20 16:47:54
updated:
---
##题目
[传送门](http://118.190.20.162/view.page?gpid=T65)
<!--more-->
{% asset_img 1.png %}
##思路
最短路变形,观察到这题中连续走小路花费为$ s^2 $.这就使得我们必须把大路和小路分开,dd[i]表示从1~i的最短路径且是以大路结尾的;dx[i]表示从1~i的最短路径且是以小路结尾的。我们可以知道在利用最短路维护时存在四种情况: 大 + 下一条路径为大路,大 + 下一条路径为小路，小 + 下一条路径为大路, 小 + 下一条路径为小路。
PS: 由于小 + 小 路程为$ s^2$ 不好处理,所以这路我们利用floyd预处理任两点之间小路的最短路然后通过spfa维护上面三种情况即可。

```C++
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f

using namespace std;
const int maxn = 555;
typedef long long ll;
ll dx[maxn],dd[maxn];
ll mpx[maxn][maxn],mpd[maxn][maxn];
int n,m;
int vis[maxn];
void Floyd()
{
    for(int k = 1;k <= n;++k)
        for(int i = 1;i <= n;++i)
        for(int j = 1;j <= n;++j)
        mpx[i][j] = min(mpx[i][j],mpx[i][k] + mpx[k][j]);
    return ;
}
int main()
{
    cin >> n >> m;
    memset(dx,inf,sizeof dx);
    memset(dd,inf,sizeof dd);
    memset(mpx,inf,sizeof mpx);
    memset(mpd,inf,sizeof mpd);
    memset(vis,0,sizeof vis);
    for(int i = 1;i <= m;++i)
    {
        int t,a,b,c;
        scanf("%d %d %d %d",&t,&a,&b,&c);
        if(t == 1 && mpx[a][b] > c)
            mpx[a][b] = mpx[b][a] = c;
        else if(t == 0 && mpd[a][b] > c)
            mpd[a][b] = mpd[b][a] = c;
    }
    Floyd();
    dx[1] = 0,dd[1] = 0;
    queue<int>q;
    vis[1] = 1;
    q.push(1);
    while(!q.empty())
    {
        int cur = q.front();q.pop();
        vis[cur] = 0;
        for(int nxt = 1;nxt <= n;++nxt)//必须遍历所有点
        {
            ll d1 = mpd[cur][nxt];
            ll d2 = mpx[cur][nxt];
            if(dd[nxt] > dd[cur] + d1)
            {
                dd[nxt] = dd[cur] + d1;
                if(vis[nxt]) continue;
                vis[nxt] = 1;
                q.push(nxt);
            }
            if(dd[nxt] > dx[cur] + d1)
            {
                dd[nxt] = dx[cur] + d1;
                if(vis[nxt]) continue;
                vis[nxt] = 1;
                q.push(nxt);
            }
            if(d2 >=  inf) continue;
            if(dx[nxt] > dd[cur] + d2 * d2)
            {
                dx[nxt] = dd[cur] + d2 * d2;
                if(vis[nxt]) continue;
                vis[nxt] = 1;
                q.push(nxt);
            }
        }
    }
    cout << min(dd[n],dx[n]) <<endl;
    return 0;
}

```